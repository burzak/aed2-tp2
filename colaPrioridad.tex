\section{colaPrioridadMin($\sigma$)}

\textbf{parámetros formales}\hangindent=2\parindent\\
\parbox{1.7cm}{\textbf{géneros}}  $\sigma$\\
\parbox[t]{1.7cm}{\textbf{función}}\parbox[t]{\textwidth-2\parindent-1.7cm}{%
\InterfazFuncion{$\bullet$=$\bullet$}{\In{s1, s2}{$\sigma$}}{$\sigma$}
{$res \igobs s1 = s2$}
[$O(1)$]
[función de igualdad de $\sigma$'s]
}

\subsection{Interfaz}

\InterfazFuncion{Vacia}{}{colaPrioridadMin($\sigma$)}
{res = vacia}
[O(1)]
[Crea una cola de prioridad vacia]\\

\InterfazFuncion{EsVacia?}{\In {c}{colaPrioridadMin($\sigma$)}}{bool}
{$res \igobs vacia?(c)$}
[O(1)]
[Devuelve verdadero si la lista es vacia.]\\

\InterfazFuncion{Proximo}{\In {c}{colaPrioridadMin($\sigma$)}}{$\sigma$}
[$\neg EsVacia?(x)$]
{$res \igobs proximo(c)$}
[O(1)]
[Devuelve el valor del primer elemento de la cola de prioridad]\\

\InterfazFuncion{Encolar}{\Inout {c}{colaPrioridadMin($\sigma$)}, \In {x}{$\sigma$}}{iterColaMin}
{$res \igobs encolar(x,c)$}
[O(log(n))]
[Agrega un elemento a la cola de prioridad. Devuelve un iterador apuntando al elemento insertado]\\

\InterfazFuncion{Desencolar}{\Inout {c}{colaPrioridadMin($\sigma$)}}{}
[$\neg EsVacia?(x)$]
{$res \igobs desencolar(c)$}
[O(log(n))]
[Elimina el proximo elemento de la cola de prioridad.]\\

% FALTA BORRAR DEL ITERADOR

\begin{Representacion}
\subsection{Justificacion}
	\begin{Estructura}{colaPrioridadMin}[tupla(raiz: puntero(nodoHeap($\sigma$)), padreAgregar: puntero(nodoHeap($\sigma$)))]
		\begin{Tupla}[nodoHeap]
			\tupItem{padre}{puntero(nodoHeap($\sigma$))}
			\tupItem{izq}{puntero(nodoHeap($\sigma$))}
			\tupItem{der}{puntero(nodoHeap($\sigma$))}
			\tupItem{clave}{$\kappa$}
			\tupItem{significado}{$\beta$}
		\end{Tupla}
	\end{Estructura}
\subsection{Invariante de representación}

\textbf{Informal}
(1)Para todo nodo, sus hijos no pueden tenerlo como hijo.
(2)Todas las hojas tienen significado.
(3)La raíz no tiene padre.
(4)Árbol binario perfectamente balanceado e izquierdista.
(5)La clave de cada nodo es menor o igual a la de sus hijos (si los tiene).
(6)Todo subárbol es un heap.

\subsection{Predicado de abtraccion}

%\AbsFc[puntero(nodo)]{dicc(string, $\sigma$)}[p]{ d : dicc(string,$\sigma$) | $(\forall s:string)\Big( \big(Def?(s,d)$ $\Longleftrightarrow (encontrarPalabra(s,p) \neq NULL$ $\yluego$ $encontrarPalabra(s,p)\to significado \neq NULL)\big)$ $\land$ $\big(*(encontrarPalabra(s,p)\to significado) = obtener(s,p)\big)\Big)$}


%~  
% \tadOperacion{encontrarPalabra}{string,puntero(nodo)}{puntero(nodo)}{}
%  \tadAxioma{encontrarPalabra($s$, $p$)}{\IF $vacia(s)$ $\lor$ $p=NULL$  THEN $p$ ELSE encontrarPalabra($fin(s)$, $p\to caracteres$[$ord(prim(s))$]) FI}

\subsection{Algoritmos}

\begin{Algoritmos}

\begin{algorithm}[H]{\textbf{iVacia}() $\to$ res: puntero(nodoHeap($\sigma$))}
	\begin{algorithmic}[1]
		%\State a $\gets$ puntero(nodoHeap($\sigma$)) \Comment O(1), creo un nodo vacío
		\State $res \gets NULL$ \Comment O(1)
		
		\medskip
		\Statex \underline{Complejidad:} O(1)
			\Statex \underline{Justificacion:} Crea un heap vacio, como siempre va a tener que crear una raíz vacía, la complejidad queda constante.
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iEsVacia?}(\In {r}{puntero(nodoHeap($\sigma$))}) $\to$ res: bool)}
	\begin{algorithmic}[1]
		\State $res \gets r = NULL$ \Comment O(1)
		
		\medskip
		\Statex \underline{Complejidad:} O(1)
			\Statex \underline{Justificacion:} Hace una comparación con la raíz para verificar que la cola de prioridad esté vacía.
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iEncolar}(\Inout {c}{colaPrioridadMin($\sigma$)}, \In {c}{$\sigma$}, \In {s}{$\sigma$}) $\to$ res: iter}
	\begin{algorithmic}[1]

		% Insertamos el elemento
		\State BuscarPadreAgregar(c) \Comment O(log(n))
		
		\ puntero(nodoHeap($\sigma$)) nuevo $\leftarrow$ c.padreAgregar$\rightarrow$izq	\Comment O(1)

		\State nuevo$\rightarrow$izq $\leftarrow$ NULL \Comment O(1)
		\State nuevo$\rightarrow$der $\leftarrow$ NULL \Comment O(1)
		\State nuevo.clave $\leftarrow$ c \Comment O(1)
		\State nuevo.significado $\leftarrow$ b \Comment O(1)
		\State nuevo$\rightarrow$padre $\leftarrow$ c.padreAgregar \Comment O(1)
				
		\If{c.padreAgregar$\rightarrow$izq = NULL} \Comment O(1)
			\State c.padreAgregar$\rightarrow$izq $\leftarrow$ nuevo \Comment O(1)
		\Else
			\State c.padreAgregar$\rightarrow$der $\leftarrow$ nuevo \Comment O(1)
		\EndIf

		% Sift up
				
		\While{nuevo.clave < nuevo$\rightarrow$padre.clave} \Comment O(log(n))
			\State siftUp(c, nuevo)	\Comment O(1)
		\EndWhile			
		\State res$\rightarrow$nuevo
		
		
		\medskip
		\Statex \underline{Complejidad:} O(log(n))
			\Statex \underline{Justificacion: Se agrega un elemento al fondo del heap, luego se utiliza la función sift-up para volver a la propiedad de heap. Ocurren varias operaciones independientes que tienen complejidad O(log(n)), por lo tanto tiene una complejidad O(log(n)).}  
	\end{algorithmic}
\end{algorithm}



\begin{algorithm}[H]{\textbf{iDesencolar}(\Inout {c}{colaPrioridadMin($\sigma$)}}
	\begin{algorithmic}[1]

		\State puntero(nodoHeap($\sigma$)) ultimo $\leftarrow$ NULL \Comment O(1)

		\If{c.padreAgregar$\rightarrow$der = NULL} \Comment O(1)
			\State ultimo $\leftarrow$ c.padreAgregar$\rightarrow$izq \Comment O(1)
			\State ultimo$\rightarrow$izq$\leftarrow$c.raiz$\rightarrow$izq \Comment O(1)
			\State ultimo$\rightarrow$der$\leftarrow$c.raiz$\rightarrow$der \Comment O(1)
			\State c.raiz$\leftarrow$ultimo \Comment O(1)
			\State c.padreAgregar$\rightarrow$izq$\leftarrow$NULL \Comment O(1)
		\Else
			\State ultimo $\leftarrow$ c.padreAgregar$\rightarrow$der \Comment O(1)
			\State ultimo$\rightarrow$izq$\leftarrow$c.raiz$\rightarrow$izq \Comment O(1)
			\State ultimo$\rightarrow$der$\leftarrow$c.raiz$\rightarrow$der \Comment O(1)
			\State c.raiz$\leftarrow$ultimo \Comment O(1)
			\State c.padreAgregar$\rightarrow$der$\leftarrow$NULL \Comment O(1)
		\EndIf
		
		%Ahora sift down
		\While {ultimo$\rightarrow$der $\neq$ NULL $\wedge$ ultimo$\rightarrow$izq $\neq$ NULL $\wedge$ (ultimo$\rightarrow$der.clave $<$ ultimo.clave $\vee$ ultimo$\rightarrow$izq.clave $<$ ultimo.clave))} \Comment O(log(n))
			\State siftDown(ultimo, c) \Comment O(1)
		\EndWhile
		
		\medskip
		\Statex \underline{Complejidad:} O(log(n))
			\Statex \underline{Justificacion: Se elimina el primer elemento del heap, se reemplaza la raiz por el último elemento, luego se utiliza la función sift-down para volver a tener la propiedad de heap. El ciclo itera como máximo log(n) veces, que es la altura del heap (sólo se puede llevar hasta el fondo).}   
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iProximo}(\In {c}{colaPrioridadMin($\sigma$)}) $\to$ res: $\sigma$}
	\begin{algorithmic}[1]
		
		\State res$\leftarrow$c$\rightarrow$raiz.significado
		
		\medskip
		\Statex \underline{Complejidad:} O(1)
			\Statex \underline{Se obtiene el significado de la raiz del heap.}   
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iProximo}(\In {c}{colaPrioridadMin($\sigma$)}) $\to$ res: $\sigma$}
	\begin{algorithmic}[1]
		
		\State res$\leftarrow$c$\rightarrow$raiz.significado
		
		\medskip
		\Statex \underline{Complejidad:} O(1)
			\Statex \underline{Se obtiene el significado de la raiz del heap.}   
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{BuscarPadreInsertar}(\In {c}{colaPrioridadMin($\sigma$)})}
	\begin{algorithmic}[1]
		
		\If {c.padreAgregar$\rightarrow$der $\neq$ NULL}
			\State puntero(nodoHeap($\sigma$)) aux $\leftarrow$ c.padreAgregar
			\While {aux $\neq$ c.raiz $\wedge$ aux$\rightarrow$padre$\rightarrow$der = aux}
				\State aux $\leftarrow$ aux$\rightarrow$padre			
			\EndWhile
			\If {aux $\neq$ c.raiz}
				\State aux $\leftarrow$ aux$\rightarrow$padre
				\State aux $\leftarrow$ aux$\rightarrow$der
			\EndIf
			\While {aux$\rightarrow$izq $\neq$ NULL}
				\State aux $\leftarrow$ aux$\rightarrow$izq
			\EndWhile
			\State c.padreAgregar $\leftarrow$ aux
		\EndIf
		
		\medskip
		\Statex \underline{Complejidad:} O(log(n))
			\Statex \underline{Se obtiene nodo al cual hay que agregarle hojas para mantener la propiedad de heap al encolar. En el peor caso se recorre dos veces la altura del heap, es decir 2log(n) operaciones, dando una complejidad O(log(n)).}   
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{siftUp}(\In {c}{colaPrioridadMin($\sigma$)}, \In {n}{puntero(nodoHeap($\sigma$))})}
	\begin{algorithmic}[1]
		
		\State puntero(nodoHeap($\sigma$)) aux $\leftarrow$ n
		
		\If {aux$\rightarrow$izq = aux}
			aux $\leftarrow$ aux$\rightarrow$padre
			
		\EndIf		
		
		
		\medskip
		\Statex \underline{Complejidad:} O(1)
			\Statex \underline{.}   
	\end{algorithmic}
\end{algorithm}


\end{Algoritmos}

\end{Representacion}