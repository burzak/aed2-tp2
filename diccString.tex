\section{DiccString($\sigma$)}

\textbf{parámetros formales}\hangindent=2\parindent\\
\parbox{1.7cm}{\textbf{géneros}}  $\sigma$\\
\parbox[t]{1.7cm}{\textbf{función}}\parbox[t]{\textwidth-2\parindent-1.7cm}{%
\InterfazFuncion{CopiarSignificado}{\In{s}{$\sigma$}}{$\sigma$}
{$res \igobs s$}
[$O(copy(s))$]
[función de copia de $\sigma$'s]
}

\subsection{Interfaz}

\bf{Operacion del modulo}

\InterfazFuncion{Vacio}{}{DiccString($\sigma$)}
{res = Vacio()}
[O(1)]
[Crea un diccionario vacio]\\

\InterfazFuncion{Significado}{\In {s}{string}, \In {d}{DiccString($\sigma$)}}{$\sigma$}
[Definido(s, d)]
{res = Significado(s, d)}
[O(|L|), siendo L la máxima longitud de las claves en el dicc]
[Devuelve el significado del diccionario]\\

\InterfazFuncion{Definido}{\In {s}{string}, \In {d}{DiccString($\sigma$)}}{bool}
{res = Definido(s, d)}
[O(|L|), siendo L la máxima longitud de las claves en el dicc]
[Verifica si una clave existe o no en el diccionario]\\

\InterfazFuncion{Vacio?}{\In {d}{DiccString($\sigma$)}}{bool}
{res = Vacio?(d)}
[O(1)]
[Chequea si un diccionario es vacio]\\

\InterfazFuncion{Definir}{\In {s}{string}, \In {c}{$\sigma$}, \Inout {d}{DiccString($\sigma$)}}{}
[d $\igobs$ d$_0$]
{d = Definir(s, c, d$_0$)}
[O(|L|), siendo L la máxima longitud de las claves del diccionario]
[Define una clave en el diccionario]\\

\InterfazFuncion{Borrar}{\In {s}{string}, \Inout {d}{DiccString($\sigma$)}}{}
[d $=$ d$_0$]
{d $=$ Borrar(s, d$_0$)}
[O(|L|), siendo L la máxima longitud de las claves en el diccionario]
[Borra la clave, si es prefijo de alguna otra clave solo borra el significado]

\bf{Operaciones del iterador}

\begin{Representacion}

\Titulo{Representacion del modulo}
\subsection{Justificacion}
	\begin{Estructura}{diccString}[Arbolito]
		\begin{Tupla}[Arbolito]
			\tupItem{raiz}{puntero(nodo($\sigma$))}
			\tupItem{claves}{conj(string)}\\
			
		\begin{Tupla}[nodo]
			\tupItem{hijos}{arreglo[256] de puntero(nodo($\sigma$)}
			\tupItem{significado}{puntero($\sigma$)}\\
		\end{Tupla}
	\end{Estructura}
\subsection{Invariante de representación}

\textbf{Informal}
(1)Para todo nodo, sus hijos no pueden tenerlo como hijo
(2)Todas las hojas tienen significado
(3)Para todo elem en claves, elem esta definido en el diccionarioy viceversa

\subsection{Predicado de abtraccion}

\AbsFc[puntero(nodo)]{dicc(string, $\sigma$)}[p]{ d : dicc(string,$\sigma$) | $(\forall s:string)\Big( \big(Def?(s,d)$ $\Longleftrightarrow (encontrarPalabra(s,p) \neq NULL$ $\yluego$ $encontrarPalabra(s,p)\to significado \neq NULL)\big)$ $\land$ $\big(*(encontrarPalabra(s,p)\to significado) = obtener(s,p)\big)\Big)$}


~  
 \tadOperacion{encontrarPalabra}{string,puntero(nodo)}{puntero(nodo)}{}
  \tadAxioma{encontrarPalabra($s$, $p$)}{\IF $vacia(s)$ $\lor$ $p=NULL$  THEN $p$ ELSE encontrarPalabra($fin(s)$, $p\to caracteres$[$ord(prim(s))$]) FI}

\Titulo {Representacion del iterador}
\end{Representacion}
\subsection{Algoritmos}

\begin{Algoritmos}
\Titulo {Algoritmos del modulo}

\begin{algorithm}[H]{\textbf{iVacio}() $\to$ res:Arbolito)}
	\begin{algorithmic}[1]
		\State a $\gets$ arreglo[256] de puntero(nodo($\sigma$)) \Comment O(256), creo un arreglo vacio de 256 posiciones, que guarda punteros a nodo
		\State $res \gets <<a, NULL>, Vacio()>$ \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1)
			\Statex \underline{Justificacion:} Crea un arreglo vacio, como siempre va a tener 256 posiciones para cualquier entrade la complejidad queda constante, asigna y crea un conjunto vacio
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iSignificado}(\In {s}{string}, \In {d}{Arbolito}) $\to$ res: $\sigma$)}
	\begin{algorithmic}[1]
		\State nat i $\gets$ Longitud(s) \Comment O(1)
		\State puntero(nodo($\sigma$)) p $\gets$ d \Comment O(1)
		\While{i $<$ Longitud(s)} \Comment O(|s|), longitud de s
			\State p $\gets$ p $\to$ hijos[ord(s[i])] \Comment O(1)
		 	\State i $\gets$ i +1 \Comment O(1)
		 \EndWhile
		 \State res $\gets$ *(p $\to$ significado) \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(|s|)
			\Statex \underline{Justificacion:} Recorre toda la clave, usando un puntero. Cuando este llega al final devuelve el significado, ya que recorrio toda la clave por el DiccString.  
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iDefinido}(\In {s}{string}, \In {d}{Arbolito)}) $\to$ res: bool}
	\begin{algorithmic}[1]
		\State nat i $\gets$ Longitud(s) \Comment O(1)
		\State puntero(nodo($\sigma$)) p $\gets$ d \Comment O(1)
		\While{i $<$ Longitud(s) $\wedge$ p $\to$ hijos[ord(s[i])] $\neq$ NULL} \Comment O(|s|), longitud de s
			\State p $\gets$ p $\to$ hijos[ord(s[i])] \Comment O(1)
		 	\State i $\gets$ i +1 \Comment O(1)
		 \EndWhile
		 \State res $\gets$ (i $=$ Longitud(s)) $\wedge$ (p$\to$ significado $\neq$ NULL) \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(|s|)
			\Statex \underline{Justificacion:} En el peor de los casos recorre toda la clave para verificar si esta definida o no.  
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iVacio?}(\In {d}{Arbolito}) $\to$ res: bool}
	\begin{algorithmic}[1]
		\State bool b $\gets$ false \Comment O(1)
		\State nat i $\gets$ 0 \Comment O(1)
		\While{i $<$ 256 $\wedge$ $\neg$b} \Comment O(256), termina siendo O(1)
			\If{d $\to$ hijos[i] $\neq$ NULL} \Comment O(1)
				 \State b $\gets$ true \Comment O(1)
			\EndIf
		\EndWhile
		\State res $\gets$ (d $=$ NULL) $\vee$ (i $=$ 256)\Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1)
			\Statex \underline{Justificacion:}Chequea si el DiccString es vacio, para esto verifica si la raiz es null o que ningun existe.
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iDefinir}(\In {s}{string}, \In {c}{$\sigma$}, \Inout {d}{Arbolito})}
	\begin{algorithmic}[1]
		\State puntero(nodo($\sigma$)) p $\gets$ d \Comment O(1)
		\State nat i $\gets$ 0 \Comment O(1)
		\While{i $<$ Longitud(s)} \Comment O(|s|), longitud de s
			\If{p$\to$ hijos[ord(s[i])] $=$ NULL} \Comment O(1) 
				\State puntero(nodo($\sigma$)) $p_2$ $gets$ NULL \Comment O(1)
				\State p$\to$ hijos[ord(s[i])] $\gets$ $p_2$ \Comment O(1)	
				\State p $\gets$ p$\to$ hijos[ord(s[i])] \Comment O(1)
				\State i $\gets$ i + 1 \Comment O(1)
			\Else
				\State p $\gets$ p$\to$ hijos[ord(s[i])] \Comment O(1)
				\State i $\gets$ i + 1 \Comment O(1)
			\EndIf
		\EndWhile
		\State p$\to$ significado $\gets$ c \Comment O(1)		
		\State AgregarRapido(d.claves, s) \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(|s|)
			\Statex \underline{Justificacion:}Recorre la clave, si existe el nodo solo avanza a este sino crea una nuevo y avanza. Al final asigna el significado y lo agrega al conjunto, como recorre la clave una vez la complejidad final es O(|s|)
	\end{algorithmic}
\end{algorithm}

\Titulo {Algoritmos del iterador}
\end{Algoritmos}

