\section{Juego}

\subsection{Interfaz}

\parbox {1,7cm}{{\bf Género}} juego \\
{\bf se explica con:}  \tadNombre{Mapa}, \tadNombre{Conjunto ($\sigma$)} , \tadNombre{Secuencia($\sigma$)}\\
\medskip

\parbox {1,5cm}{\bf{Operaciones básicas}}\\

\InterfazFuncion{CrearJuego}{\In {m}{mapa}}{juego}
{res $\igobs$ crearJuego(m)}
[O(1)]
[Creo un nuevo juego tomando un mapa]\\

\InterfazFuncion{AgregarPokemon}{\In {p}{pokemon}, \In {c}{coordenada}, \Inout {g}{juego}}{}
[puedoAgregarPokemon(c, j) $\wedge$ g $\igobs$ g$_0$]
{g = agregarPokemon(p, c, g$_0$)}
[O(??)]
[Agrego un pokemon al juego]\\

\InterfazFuncion{AgregarJugador}{\In {g}{juego}}{it(jugador)}
[g $\igobs$ g$_0$]
{g = agregarJugador(g$_0$)}
[O(J), Siendo J la cantidad de jugadores que fueron agregados al juego]
[Agrega un jugador al juego]\\

\InterfazFuncion{Conectarse}{\In {j}{jugador}, \In {c}{coordenada}, \Inout {g}{juego}}{}
[g $\igobs$ g$_0$ $\wedge$ j $\in$ jugadores(g) $\yluego$ $\neg$estaConectado(j, g) $\wedge$ posExistente(c, mapa(g))]
{g = conectarse(g$_0$)}
[O(log(EC)), siendo EC la máxima cantidad de jugadoes esperando capturar un pokémon]
[Conecta un jugador al juego, con todo lo que esto implica]\\

\InterfazFuncion{Desconectarse}{\In {j}{jugador}, \Inout{g}{juego}}{}
[g $\igobs$ g$_0$ $\wedge$ j $\in$ jugadores(g) $\yluego$ estaConectado(j, g)]
{g = desconectarse(j, g$_0$)}
[O(log(EC)), siendo EC la máxima cantidad de jugadoes esperando capturar un pokémon]
[Desconecta al jugador j del juego]\\

\InterfazFuncion{Moverse}{\In {j}{jugador}, \In {c}{coordenada}, \Inout {g}{juego}}{}
[g $\igobs$ g$_0$ $\wedge$ j $\in$ jugadores(g) $\yluego$ estaConectado(j, g) $\wedge$ posExistente(c, mapa(g))]
{g = moverse(j, c, g$_0$)}
[O(??)]
[Mueve un jugador en el mapa, verifica si hay una captura de pokémon, y para el jugador movido verifica si cometió alguna infracción]\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OBSERVADORES BASICOS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\InterfazFuncion{Mapa}{\In {g}{Juego}}{Mapa}
{res $\igobs$ mapa(g)}
[O(1)]
[Devuelve la instancia de mapa que tenemos guardada]
\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\bf{Operaciones del iterador}\\

\InterfazFuncion{CrearIt}{\In {g}{game}}{itJuego($\sigma$)}
{res = CrearItUni(v)}
[O(1)]
[Crea un iterador unidireccional no modificable al principio del vector, no necesariamente es un elemento válido por ende no se puede usar Actual sin Avanzar]
[]\\

\InterfazFuncion{HayMas?}{\In {it}{itJuego($\sigma$)}}{bool}
{res $\igobs$ HayMas?(it)}
[O(n), siendo n la cantidad de elementos del vector]
[Devuelve true si y solo si quedan elementos para avanzar]\\

\InterfazFuncion{Avanzar}{\Inout {it}{itJuego($\sigma$)}}{}
[HayMas?(it) $\wedge$ it $\igobs$ it$_0$]
{it $\igobs$ Avanzar(it$_0$)}
[O(n), siendo n la cantidad de elementos del vector]
[Avanza el iterador al próximo elemento del vector]\\

\InterfazFuncion{Actual}{\In {it}{itJuego($\sigma$)}}{$\sigma$}
[HayMas?(it)]
{res $\igobs$ Actual(it)}
[O(1)]
[Devuelve el elemento apuntado por el iterador]
[res no es modificable porque el iterador no es modificable]\\

\InterfazFuncion{Siguientes}{\In {it}{itJuego($\sigma$)}}{lista($\sigma$)}
{res $\igobs$ Siguientes(it)}
[O(n), siendo n la cantidad de elementos del vector]
[Devuelve los elementos del vector posteriores al iterador, puede no haber ninguno]\\


\begin{Representacion}
\Titulo{Representacion del modulo}
\subsubsection{Justificación}
	\begin{Estructura}{Juego}[Game]
		\begin{Tupla}[Game]
			\tupItem{pokemons}{diccString(pokemon, tupla <cantSalvaje: Nat, cantTotal: Nat>}
			\tupItem{\\mapa}{Mapa}
			\tupItem{\\jugadores}{Vector(InfoJugador)}
			\tupItem{\\mapaInfo}{Vector(Vector(CosaFea)}
			\tupItem{\\cantidadTotPokémons}{Nat}
			\tupItem{\\coordenadasPokemons}{Lista(tupla<Pokemon, Coordenada>)}
		\end{Tupla}
	\end{Estructura}
	
	\begin{Tupla}[InfoJugador]
		\tupItem{conectado}{Bool}
		\tupItem{\\expulsado}{Bool}
		\tupItem{\\sanciones}{Nat}
		\tupItem{\\pos}{Coordenada}
		\tupItem{\\pokemons}{dicc(pokemon, cant: nat)}
		\tupItem{\\posicionMapa}{itlista(tupla<jugador: Nat, EsperandoCapturar: itColaDePrioridad(cantPokemon)>)}
		\tupItem{\\cantTotalPoke}{Nat}
	\end{Tupla}
	
	
	\begin{Tupla}[CosaFea]
		\tupItem{\\jugEspe}{ColaDePrioridad(cantPokemon)}
		\tupItem{\\hayPokemon}{Bool}
		\tupItem{\\jugadores}{ListaEnlazada(jugador, itColaDePrioridad(cantPokemon))}
		\tupItem{\\MovimientosRestantes}{Nat}
	\end{Tupla}

\subsubsection{Invariante de representación}

\subsubsection{Predicado de abtraccion}

	\Titulo{Representacion del iterador}
\subsection{Justificacion}

	\begin{Estructura}{itVector(infoJugador)}[iter]
		\begin{Tupla}[iter]
		\tupItem{posicion}{nat}
		\tupItem{vector}{puntero(Vector(infoJugador))}
		\end{Tupla}
	\end{Estructura}
\subsection{Invariante de representacion}

\textbf{Informal}

\textbf{Formal}

\subsection{Predicado de abstraccion}

\end{Representacion}
\subsection{Algoritmos}

\begin{Algoritmos}
\Titulo {Algoritmos del Modulo}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Generadores
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{algorithm}[H]{\textbf{iCrearJuego}(\In {m}{mapa}) $\to$ res: Game}
	\begin{algorithmic}[1]
		\State res $\gets$ <Vacio(), m, Vac\'ia(), Vac\'ia(), 0, Vac\'ia()> 
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:} Todo es O(1) ya que estoy creando una tupla con estructuras vac\'ias que son $\Theta$(1) y una asignaci\'on
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iAgregarJugador}(\In {g}{Game}) $\to$ res: itJuego($\sigma$)}
	\begin{algorithmic}[1]
		\State AgregarAtras (g.jugadroes, <false, false, 0, <0, 0>, Vacio(), NULL, 0>) \Comment O(longitud(g.jugadores) + copy(tupla))
		\State   itJuego($\sigma$) it $\gets$ CrearIt(g) \Comment O(1)
		\While {it.posicion $<$ Longitud(g.jugadores)} \Comment O(longitud(g.jugadores))
			\State it.posicion $\gets$ it.posicion + 1 \Comment O(1)
		\EndWhile
		\State res $\gets$ it \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(longitud(g.jugadores))
		\Statex \underline{Justificacion:}Agrega un jugador al juego, el costo de copiar la tupla es O(1) porque todas las componentes están vacías, después crea un iterador al principio del vector y lo avanza hasta la última posición donde fue agregado el jugador y lo devuelve. Para hacer esto último tengo que recorrer todo el vector entonces la complejidad final es O(longitud(g.jugadores) + (longitud(g.jugadores) + copiar(tupla))), como dijimos el costo de copiar  
	\end{algorithmic}
\end{algorithm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OBSERVADORES BASICOS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{algorithm}[H]{\textbf{iMapa}(\In {g}{Game}) $\to$ res: mapa}
	\begin{algorithmic}[1]
		\State res $\gets$ g.mapa \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:} Devuelve la instancia de mapa que tenemos guardada
	\end{algorithmic}
\end{algorithm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Iterador
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\Titulo {Algoritmos del iterador}

\begin{algorithm}[H]{\textbf{iCrearIt}(\In {v}{Vector(infoJugador)}) $\to$ res: iter))}
	\begin{algorithmic}[1]
		\State res $\gets$ <0, v> \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:}Crea un iterador al princio del vector, solo 
		realiza una asignación  
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iHayMas?}(\In {it}{iter}) $\to$ res: bool))}
	\begin{algorithmic}[1]
		\State bool b $\gets$ false
		\State nat i $\gets$ it.posicion \Comment O(1)
		\While {i $<$ it.vector$\to$ longitud $\wedge$ $\neg$b} \Comment O(longitud(v))
			\If {it.vector$\to$ elementos[i].expulsado $=$ false} \Comment O(1)
				\State b $\gets$ true \Comment O(1)
			\EndIf
		\State i $\gets$ i +1 \Comment O(1)		
		\EndWhile
		\State res $\gets$ b
		\medskip
		\Statex \underline{Complejidad:} O(longitud(v))
		\Statex \underline{Justificacion:}En el peor de lo casos hay que recorrer todo el vector para saber si existe otro elemento

\end{algorithmic}
\end{algorithm}	
		
\begin{algorithm}[H]{\textbf{iAvanzar}(\Inout {it}{iter})}
	\begin{algorithmic}[1]
		\State bool b $\gets$ false
		\State nat i $\gets$ it.posicion \Comment O(1)
		\While {i $<$ it.vector$\to$ longitud $\wedge$ $\neg$b} \Comment O(longitud(v))
			\If {it.vector$\to$ elementos[i].expulsado $=$ false} \Comment O(1)
				\State b $\gets$ true \Comment O(1)
			\EndIf
		\State i $\gets$ i +1 \Comment O(1)		
		\EndWhile
		\State it.posicion $\gets$ i \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(longitud(v))
		\Statex \underline{Justificacion:}Recorre el vector y para en el primer elemento válido, que existe por la precondición de la función, luego actualiza la posición del iterador  
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iActual}(\In {it}{iter}) $\to$ res: infoJugador))}
	\begin{algorithmic}[1]
		\State res $\gets$ it.vector$\to$ elementos[it.posicion] \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:}Se mete al vector a travéz del iterador y devuelve el contenido del vector en la posición en donde está el iterador  
	\end{algorithmic}
\end{algorithm}
	
\begin{algorithm}[H]{\textbf{iSiguientes}(\In {it}{iter}) $\to$ res: lista(infoJugador)))}
	\begin{algorithmic}[1]
		\State lista(infoJugador) ls $\gets$ Vacia() \Comment O(1), crea una lista vacia
		\State nat i $\gets$ it.posicion \Comment O(1)
		\While {i $<$ it.vector$\to$ longitud} \Comment O(longitud(v)$*$copy(infoJugador))
			\If {it.vector$\to$ elementos[i].expulsado $=$ false} \Comment O(1)
				\State AgregarAtras(ls, it.vector$\to$ elementos[i]) \Comment O(copy (infoJugador))
			\EndIf
		\State i $\gets$ i +1 \Comment O(1)		
		\EndWhile
		\State res $\gets$ ls \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(longitud(v) *copy(infoJugador))
		\Statex \underline{Justificacion:}Para devolver una lista con los elementos que quedan por recorrer, recorro todo el vector viendo que elementos son válidos y si un elemento es válido lo agrego a una lista, considerando el costo de copiar el elemento.
	\end{algorithmic}
\end{algorithm}

\end{Algoritmos}