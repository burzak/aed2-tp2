\section{Juego}

\subsection{Interfaz}

\parbox {1,7cm}{{\bf Género}} juego \\
{\bf se explica con:}  \tadNombre{Mapa}, \tadNombre{Conjunto ($\sigma$)} , \tadNombre{Secuencia($\sigma$)}\\
\medskip

\parbox {1,5cm}{\bf{Operaciones básicas}}\\

\InterfazFuncion{CrearJuego}{\In {m}{mapa}}{juego}
{res $\igobs$ crearJuego(m)}
[O(1)]
[Creo un nuevo juego tomando un mapa]\\

\InterfazFuncion{AgregarPokemon}{\In {p}{pokemon}, \In {c}{coordenada}, \Inout {g}{juego}}{}
[puedoAgregarPokemon(c, j) $\wedge$ g $\igobs$ g$_0$]
{g = agregarPokemon(p, c, g$_0$)}
[O(??)]
[Agrego un pokemon al juego]\\

\InterfazFuncion{AgregarJugador}{\In {g}{juego}}{it(jugador)}
[g $\igobs$ g$_0$]
{g = agregarJugador(g$_0$)}
[O(J), Siendo J la cantidad de jugadores que fueron agregados al juego]
[Agrega un jugador al juego]\\

\InterfazFuncion{Conectarse}{\In {j}{jugador}, \In {c}{coordenada}, \Inout {g}{juego}}{}
[g $\igobs$ g$_0$ $\wedge$ j $\in$ jugadores(g) $\yluego$ $\neg$estaConectado(j, g) $\wedge$ posExistente(c, mapa(g))]
{g = conectarse(g$_0$)}
[O(log(EC)), siendo EC la máxima cantidad de jugadoes esperando capturar un pokémon]
[Conecta un jugador al juego, con todo lo que esto implica]\\

\InterfazFuncion{Desconectarse}{\In {j}{jugador}, \Inout{g}{juego}}{}
[g $\igobs$ g$_0$ $\wedge$ j $\in$ jugadores(g) $\yluego$ estaConectado(j, g)]
{g = desconectarse(j, g$_0$)}
[O(log(EC)), siendo EC la máxima cantidad de jugadoes esperando capturar un pokémon]
[Desconecta al jugador j del juego]\\

\InterfazFuncion{Moverse}{\In {j}{jugador}, \In {c}{coordenada}, \Inout {g}{juego}}{}
[g $\igobs$ g$_0$ $\wedge$ j $\in$ jugadores(g) $\yluego$ estaConectado(j, g) $\wedge$ posExistente(c, mapa(g))]
{g = moverse(j, c, g$_0$)}
[O(??)]
[Mueve un jugador en el mapa, verifica si hay una captura de pokémon, y para el jugador movido verifica si cometió alguna infracción]\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OBSERVADORES BASICOS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\InterfazFuncion{Mapa}{\In {g}{Juego}}{Mapa}
{res $\igobs$ mapa(g)}
[O(1)]
[Devuelve la instancia de mapa que tenemos guardada]
\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\bf{Operaciones del iterador}\\

\InterfazFuncion{CrearIt}{\In {g}{game}}{itJugador}
{res = CrearItUni(v)}
[O(1)]
[Crea un iterador unidireccional no modificable al principio del vector, no necesariamente es un elemento válido por ende no se puede usar Actual sin Avanzar]
[]\\

\InterfazFuncion{HayMas?}{\In {it}{itJugador}}{bool}
{res $\igobs$ HayMas?(it)}
[O(n), siendo n la cantidad de elementos del vector]
[Devuelve true si y solo si quedan elementos para avanzar]\\

\InterfazFuncion{Avanzar}{\Inout {it}{itJugador}}{}
[HayMas?(it) $\wedge$ it $\igobs$ it$_0$]
{it $\igobs$ Avanzar(it$_0$)}
[O(n), siendo n la cantidad de elementos del vector]
[Avanza el iterador al próximo elemento del vector]\\

\InterfazFuncion{Actual}{\In {it}{itJugador}}{Nat}
[HayMas?(it)]
{res $\igobs$ Actual(it)}
[O(1)]
[Devuelve el Id apuntado por el iterador]
[res no es modificable porque el iterador no es modificable]\\

\InterfazFuncion{Siguientes}{\In {it}{itJugador)}}{lista($\sigma$)}
{res $\igobs$ Siguientes(it)}
[O(n), siendo n la cantidad de elementos del vector]
[Devuelve los elementos del vector posteriores al iterador, puede no haber ninguno]\\


\begin{Representacion}
\Titulo{Representacion del modulo}
\subsubsection{Justificación}
	\begin{Estructura}{Juego}[Game]
		\begin{Tupla}[Game]
			\tupItem{pokemons}{diccString(pokemon, tupla <cantSalvaje: Nat, cantTotal: Nat>}
			\tupItem{\\mapa}{Mapa}
			\tupItem{\\jugadores}{Vector(InfoJugador)}
			\tupItem{\\mapaInfo}{Arreglo de Arreglo de InfoCoordenada)}
			\tupItem{\\cantidadTotPokémons}{Nat}
			\tupItem{\\coordenadasPokemons}{Lista(tupla<Pokemon, Coordenada>)}
		\end{Tupla}
	\end{Estructura}
	
	\begin{Tupla}[InfoJugador]
		\tupItem{conectado}{Bool}
		\tupItem{\\expulsado}{Bool}
		\tupItem{\\sanciones}{Nat}
		\tupItem{\\pos}{Coordenada}
		\tupItem{\\pokemons}{dicc(pokemon, cant: nat)}
		\tupItem{\\posicionMapa}{itlista(tupla<jugador: Nat, EsperandoCapturar: itColaDePrioridad(cantPokemon)>)}
		\tupItem{\\cantTotalPoke}{Nat}
	\end{Tupla}
	
	
	\begin{Tupla}[InfoCoordenada]
		\tupItem{\\jugEspe}{ColaDePrioridad(cantPokemon)}
		\tupItem{\\hayPokemon}{Bool}
		\tupItem{\\jugadores}{ListaEnlazada(jugador, itColaDePrioridad(cantPokemon))}
		\tupItem{\\MovimientosRestantes}{Nat}
	\end{Tupla}

\subsubsection{Invariante de representación}

\subsubsection{Predicado de abtraccion}

	\Titulo{Representacion del iterador}
\subsection{Justificacion}

	\begin{Estructura}{itJugador}[iter]
		\begin{Tupla}[iter]
		\tupItem{posicion}{nat}
		\tupItem{vector}{puntero(Vector(infoJugador))}
		\end{Tupla}
	\end{Estructura}
\subsection{Invariante de representacion}

\textbf{Informal}

\textbf{Formal}

\subsection{Predicado de abstraccion}

\end{Representacion}
\subsection{Algoritmos}

\begin{Algoritmos}
\Titulo {Algoritmos del Modulo}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Generadores
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{algorithm}[H]{\textbf{iCrearJuego}(\In {m}{mapa}) $\to$ res: Game}
	\begin{algorithmic}[1]
		\State coords $\gets$ Coordenadas(m) \Comment O(1)
		\State iter $\gets$ CrearIt(coords) \Comment O(1)
		\State ancho $\gets$ 0 \Comment O(1)
		\State alto $\gets$ 0 \Comment O(1)
		\While{HaySiguiente(iter)} \Comment O($\#$coords)
			\State c $\gets$ Siguiente(iter) \Comment O(1)
			\State Avanzar(iter) \Comment O(1)
			\State \IF Altitud(c) > alto THEN alto $\gets$ Altitud(c) ELSE FI \Comment O(1)
			\State \IF Longitud(c) > ancho THEN ancho $\gets$ Longitud(c) ELSE FI \Comment O(1)
		\EndWhile
		\State infocoor $\gets$ arreglo[ancho] de arreglo[alto] de <Vac\'ia(), Bool, Vac\'ia(), 10> \Comment O(m.ancho * m.alto)
		\State res $\gets$ <Vacio(), m, Vac\'ia(), infocoor, 0, Vac\'ia()> \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(TM)
		\Statex \underline{Justificacion:} Donde TM es el tama\~no del mapa (alto $\times$ ancho)
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iAgregarJugador}(\In {g}{Game}) $\to$ res: itJuego($\sigma$)}
	\begin{algorithmic}[1]
		\State AgregarAtras (g.jugadroes, <false, false, 0, <0, 0>, Vacio(), NULL, 0>) \Comment O(longitud(g.jugadores) + copy(tupla))
		\State   itJuego($\sigma$) it $\gets$ CrearIt(g) \Comment O(1)
		\While {it.posicion $<$ Longitud(g.jugadores)} \Comment O(longitud(g.jugadores))
			\State it.posicion $\gets$ it.posicion + 1 \Comment O(1)
		\EndWhile
		\State res $\gets$ it \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(longitud(g.jugadores))
		\Statex \underline{Justificacion:}Agrega un jugador al juego, el costo de copiar la tupla es O(1) porque todas las componentes están vacías, después crea un iterador al principio del vector y lo avanza hasta la última posición donde fue agregado el jugador y lo devuelve. Para hacer esto último tengo que recorrer todo el vector entonces la complejidad final es O(longitud(g.jugadores) + (longitud(g.jugadores) + copiar(tupla))), como dijimos el costo de copiar  
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iAgregarPokemon}(\In {p}{string}, \In {c}{coordenada}, \In {g}{game})}
	\begin{algorithmic}[1]
		\State AgregarRapido(g.coordenadasPokemons, c) \Comment O(copiar(c)) = O(1)
		\If{$\neg$Definido(p, g.pokemons)} \Comment O(2*|p|) = O(|p|)
			\State Definir(p, <1, 0>, g.pokemons) \Comment O(|P|)
		\Else
			\State Definir(p, <Significado(p, g.pokemons).cantSalvaje +1, Significado(p, g.pokemons).cantAtrapados>, g.pokemons) \Comment O(|p|)
		\EndIf
		\State g.mapaInfo[c].hayPokemon $\gets$ true \Comment O(1)
		\State g.mapaInfo[c].movimientosRestantes $\gets$ 0 \Comment O(1)
		\State lista(coordenada) lc $\gets$ Vacia() \Comment O(1)
		
		\medskip
		\Statex \underline{Complejidad:} O(longitud(g.jugadores))
		\Statex \underline{Justificacion:}  
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iCeldasValidas}(\In {g}{Game}, \In {c}{coordenada}, \In {n}{nat}) $\to$ res: lista(coordenada)}
	\begin{algorithmic}[1]
		\State lista(coordenada) ls $\gets$ Vacia() \Comment O(1)
		\State nat i $\gets$ n \Comment O(1)
		\While {i $>$ 0}
			\If {g.mapaInfo[<c.latitud+i, c.longitud+i>].coordenadaVálida $=$ true}
				\State AgregarAtras(l, <c.latitud+i, c.longitud+i>)
			\EndIf
			\If {g.mapaInfo[<c.latitud, c.longitud+i>].coordenadaVálida $=$ true}
				\State AgregarAtras(l, <c.latitud, c.longitud+i>)			
			\EndIf
			\If {g.mapaInfo[<c.latitud+i, c.longitud>].coordenadaVálida $=$ true}
				\State AgregarAtras(l, <c.latitud+i, c.longitud>)			
			\EndIf
			\If {g.mapaInfo[<c.latitud-i, c.longitud-i>].coordenadaVálida $=$ true}
				\State AgregarAtras(l, <c.latitud-i, c.longitud-i>)			
			\EndIf
			\If {g.mapaInfo[<c.latitud-i, c.longitud+i>].coordenadaVálida $=$ true}
				\State AgregarAtras(l, <c.latitud, c.longitud+i>)			
			\EndIf
			\If {g.mapaInfo[<c.latitud, c.longitud+i>].coordenadaVálida $=$ true}
				\State AgregarAtras(l, <c.latitud, c.longitud+i>)			
			\EndIf
			\If {g.mapaInfo[<c.latitud, c.longitud+i>].coordenadaVálida $=$ true}
				\State AgregarAtras(l, <c.latitud, c.longitud+i>)			
			\EndIf
			\If {g.mapaInfo[<c.latitud, c.longitud+i>].coordenadaVálida $=$ true}
				\State AgregarAtras(l, <c.latitud, c.longitud+i>)			
			\EndIf
			\If {g.mapaInfo[<c.latitud, c.longitud+i>].coordenadaVálida $=$ true}
				\State AgregarAtras(l, <c.latitud, c.longitud+i>)			
			\EndIf
			
		\EndWhile
		\medskip
		\Statex \underline{Complejidad:} O(longitud(g.jugadores))
		\Statex \underline{Justificacion:}
	\end{algorithmic}
\end{algorithm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OBSERVADORES BASICOS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{algorithm}[H]{\textbf{iMapa}(\In {g}{Game}) $\to$ res: mapa}
	\begin{algorithmic}[1]
		\State res $\gets$ g.mapa \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:} Devuelve la instancia de mapa que tenemos guardada
	\end{algorithmic}
\end{algorithm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Iterador
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\Titulo {Algoritmos del iterador}

\begin{algorithm}[H]{\textbf{iCrearIt}(\In {g}{game}) $\to$ res: iter))}
	\begin{algorithmic}[1]
		\State res $\gets$ <0, puntero(g.jugadores)> \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:}Crea un iterador al princio del vector, solo 
		realiza una asignación  
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iHayMas?}(\In {it}{iter}) $\to$ res: bool))}
	\begin{algorithmic}[1]
		\State bool b $\gets$ false
		\State nat i $\gets$ it.posicion \Comment O(1)
		\While {i $<$ it.vector$\to$ longitud $\wedge$ $\neg$b} \Comment O(longitud(v))
			\If {it.vector$\to$ elementos[i].expulsado $=$ false} \Comment O(1)
				\State b $\gets$ true \Comment O(1)
			\EndIf
		\State i $\gets$ i +1 \Comment O(1)		
		\EndWhile
		\State res $\gets$ b
		\medskip
		\Statex \underline{Complejidad:} O(longitud(v))
		\Statex \underline{Justificacion:}En el peor de lo casos hay que recorrer todo el vector para saber si existe otro elemento

\end{algorithmic}
\end{algorithm}	
		
\begin{algorithm}[H]{\textbf{iAvanzar}(\Inout {it}{iter})}
	\begin{algorithmic}[1]
		\State bool b $\gets$ false
		\State nat i $\gets$ it.posicion \Comment O(1)
		\While {i $<$ it.vector$\to$ longitud $\wedge$ $\neg$b} \Comment O(longitud(v))
			\If {it.vector$\to$ elementos[i].expulsado $=$ false} \Comment O(1)
				\State b $\gets$ true \Comment O(1)
			\EndIf
		\State i $\gets$ i +1 \Comment O(1)		
		\EndWhile
		\State it.posicion $\gets$ i \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(longitud(v))
		\Statex \underline{Justificacion:}Recorre el vector y para en el primer elemento válido, que existe por la precondición de la función, luego actualiza la posición del iterador  
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iActual}(\In {it}{iter}) $\to$ res: nat}
	\begin{algorithmic}[1]
		\State res $\gets$ it.posicion \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:}Devuelve la id del jugador que apunta el iterador  
	\end{algorithmic}
\end{algorithm}
	
\begin{algorithm}[H]{\textbf{iSiguientes}(\In {it}{iter}) $\to$ res: lista(jugadores)))}
	\begin{algorithmic}[1]
		\State lista(nat) ls $\gets$ Vacia() \Comment O(1), crea una lista vacia
		\State nat i $\gets$ it.posicion \Comment O(1)
		\While {i $<$ it.vector$\to$ longitud} \Comment O(longitud(v))
			\If {it.vector$\to$ elementos[i].expulsado $=$ false} \Comment O(1)
				\State AgregarAtras(ls, it.posicion) \Comment O(1)
			\EndIf
		\State i $\gets$ i +1 \Comment O(1)		
		\EndWhile
		\State res $\gets$ ls \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(longitud(v))
		\Statex \underline{Justificacion:}Para devolver una lista con los elementos que quedan por recorrer, recorro todo el vector viendo que elementos son válidos y si un elemento es válido lo agrego a una lista.
	\end{algorithmic}
\end{algorithm}

\end{Algoritmos}