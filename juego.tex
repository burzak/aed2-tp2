\section{Juego}

\subsection{Interfaz}

\parbox {1,7cm}{{\bf Género}} juego \\
{\bf se explica con:}  \tadNombre{Mapa}, \tadNombre{Conjunto ($\sigma$)} , \tadNombre{Secuencia($\sigma$)}\\
\medskip

\parbox {1,5cm}{\bf{Operaciones básicas}}\\

\InterfazFuncion{CrearJuego}{\In {m}{mapa}}{juego}
{res $\igobs$ crearJuego(m)}
[O(1)]
[Creo un nuevo juego tomando un mapa]\\

\InterfazFuncion{AgregarPokemon}{\In {p}{pokemon}, \In {c}{coordenada}, \Inout {g}{juego}}{}
[puedoAgregarPokemon(c, j) $\wedge$ g $\igobs$ g$_0$]
{g = agregarPokemon(p, c, g$_0$)}
[O(??)]
[Agrego un pokemon al juego]\\

\InterfazFuncion{AgregarJugador}{\In {g}{juego}}{it(jugador)}
[g $\igobs$ g$_0$]
{g = agregarJugador(g$_0$)}
[O(J), Siendo J la cantidad de jugadores que fueron agregados al juego]
[Agrega un jugador al juego]\\

\InterfazFuncion{Conectarse}{\In {j}{jugador}, \In {c}{coordenada}, \Inout {g}{juego}}{}
[g $\igobs$ g$_0$ $\wedge$ j $\in$ jugadores(g) $\yluego$ $\neg$estaConectado(j, g) $\wedge$ posExistente(c, mapa(g))]
{g = conectarse(g$_0$)}
[O(log(EC)), siendo EC la máxima cantidad de jugadoes esperando capturar un pokémon]
[Conecta un jugador al juego, con todo lo que esto implica]\\

\InterfazFuncion{Desconectarse}{\In {j}{jugador}, \Inout{g}{juego}}{}
[g $\igobs$ g$_0$ $\wedge$ j $\in$ jugadores(g) $\yluego$ estaConectado(j, g)]
{g = desconectarse(j, g$_0$)}
[O(log(EC)), siendo EC la máxima cantidad de jugadoes esperando capturar un pokémon]
[Desconecta al jugador j del juego]\\

\InterfazFuncion{Moverse}{\In {j}{jugador}, \In {c}{coordenada}, \Inout {g}{juego}}{}
[g $\igobs$ g$_0$ $\wedge$ j $\in$ jugadores(g) $\yluego$ estaConectado(j, g) $\wedge$ posExistente(c, mapa(g))]
{g = moverse(j, c, g$_0$)}
[O(??)]
[Mueve un jugador en el mapa, verifica si hay una captura de pokémon, y para el jugador movido verifica si cometió alguna infracción]\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OBSERVADORES BASICOS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\InterfazFuncion{Mapa}{\In {g}{Juego}}{Mapa}
{res $\igobs$ mapa(g)}
[O(1)]
[Devuelve la instancia de mapa que tenemos guardada]
\\

\InterfazFuncion{Jugadores}{\In {g}{Juego}}{Conj(Jugador)}
{res $\igobs$ jugadores(g)}
[O(1)]
[Devuelve la instancia de mapa que tenemos guardada]
\\

\InterfazFuncion{EstaConectado}{\In {j}{Jugador}, \In {g}{Juego}}{Bool}
[j $\in$ jugadores(g)]
{res $\igobs$ estaConectado(g)}
[O(1)]
[Dice si un jugador esta conectado o no]
\\

\InterfazFuncion{Sanciones}{\In {j}{Jugador}, \In {g}{Juego}}{Nat}
[j $\in$ jugadores(g)]
{res $\igobs$ sanciones(g)}
[O(1)]
[La cantidad de sanciones que tiene un jugador]
\\

\InterfazFuncion{Posicion}{\In {j}{Jugador}, \In {g}{Juego}}{Coordenada}
[j $\in$ jugadores(g) $\impluego$ estaConectado(j, g)]
{res $\igobs$ posicion(j, g)}
[O(1)]
[Posici\'on actual del jugador cuando se encuentra conectado]
\\

\InterfazFuncion{Pokemons}{\In {j}{Jugador}, \In {g}{Juego}}{Iter(<Pokemon, Nat>)}
[j $\in$ jugadores(g)]
{res $\igobs$ pok\'emons(j, g)}
[O(1)]
[Devuelve un iterador <Pokemon, Nat>]
\\

\InterfazFuncion{Expulsados}{\In {g}{Juego}}{Conj(Jugador)}
{res $\igobs$ expulsados(g)}
[O(J)]
[Conjunto de jugadores expulsados del juego]
\\

\InterfazFuncion{PosConPokemons}{\In {g}{Juego}}{Conj(coor)}
{res $\igobs$ posConPok\'emons(g)}
[O(1)]
[Conjunto de coordenadas con Pok\'emones]
\\

\InterfazFuncion{PokemonEnPos}{\In {c}{Coordenada}, \In {g}{Juego}}{Pokemon}
[c $\in$ posConPokemons(g)]
{res $\igobs$ pokemonEnPos}
[O(1)]
[Devolvemos el Pokemon en la Coordenada]
\\




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\bf{Operaciones del iterador}\\

\InterfazFuncion{CrearIt}{\In {g}{game}}{itJugador}
{res = CrearItUni(v)}
[O(1)]
[Crea un iterador unidireccional no modificable al principio del vector, no necesariamente es un elemento válido por ende no se puede usar Actual sin Avanzar]
[]\\

\InterfazFuncion{HayMas?}{\In {it}{itJugador}}{bool}
{res $\igobs$ HayMas?(it)}
[O(n), siendo n la cantidad de elementos del vector]
[Devuelve true si y solo si quedan elementos para avanzar]\\

\InterfazFuncion{Avanzar}{\Inout {it}{itJugador}}{}
[HayMas?(it) $\wedge$ it $\igobs$ it$_0$]
{it $\igobs$ Avanzar(it$_0$)}
[O(n), siendo n la cantidad de elementos del vector]
[Avanza el iterador al próximo elemento del vector]\\

\InterfazFuncion{Actual}{\In {it}{itJugador}}{Nat}
[HayMas?(it)]
{res $\igobs$ Actual(it)}
[O(1)]
[Devuelve el Id apuntado por el iterador]
[res no es modificable porque el iterador no es modificable]\\

\InterfazFuncion{Siguientes}{\In {it}{itJugador)}}{lista($\sigma$)}
{res $\igobs$ Siguientes(it)}
[O(n), siendo n la cantidad de elementos del vector]
[Devuelve los elementos del vector posteriores al iterador, puede no haber ninguno]\\

\bf{No exportable, operaciones auxiliares}\\

\InterfazFuncion{CeldasValidas}{\In {g}{juego}, \In {c}{coordenada}}{lista(coordenadas)}
[c $\in$ coordenadas(mapa(g))]
{($\forall c_1$: coordenada)(esta?($c_1$, res)$\impluego$(distEuclidea($c_1$, c)$\leq$2  $\wedge$ posExistente($c_1$, mapa(g)))}
[Devuelve una lista con las coordenas a una distancia no mayor de 2 de la coordenada c y que ademas existan en el mapa del juego]

\begin{Representacion}
\Titulo{Representacion del modulo}
\subsubsection{Justificación}
Game representa un Juego.\\
En pokemons guardamos un diccionario sobre Trie y la clave es el Pokemon (string). Esto nos permite encontrar un pokemon en |P|. En el diccionario guardamos la cantidad de pokemones salvajes que hay y cuantos hubieron de ese tipo en total para poder calcular la rareza del pokemon en O(|P|) junto con cantidadTotPokemons que es el total de los Pokemons en el juego.
En mapa guardamos el mapa con el que se crea el Juego.\\
coordenadasConPokemons guardamos un conjunto de Coordenadas donde hay pokemones para poder devolver en posConPok\'emons en O(1).
En jugadores de game guardamos un vector de InfoJugador (ver m\'as abajo). Como en InfoCoordenada guardamos una lista de jugadores en cada coordenada y cuando expulsamos un jugador debemos borrar de forma eficiente en esa lista guardamos un iterador al jugador en diccionario para poder cumplir con los ordenes de mover.\\
mapainfo es una matriz de InfoCoordenadas donde cada dimensi\'on es la latitud y longitud de una coordenada.\\
cantidadTotPokemones guardamos el total de pokemones del juego.\\
coordenaadasPokemons es un diccionario $<$Coordenada, Pokemon$>$ donde guardamos el Pokemon que cada coordenada del Mapa tiene.\\
pokemonsDeJugadores es una lista donde guardamos los Pokemones que atrapó cada jugador. (\textbf{**}) Esto lo tuvimos que guardar fuera de InfoJugador porque ten\'iamos un problema de complejidad al agregar un jugador nuevo. Como usabamos un Vector de jugadores el agregar es O(J + copy($\alpha$)) y guardar los Pokemones que atrapo el jugador hacía que el copy no fuera O(1), entonces guardamos un iterador a esta lista en InfoJugador.\\
InfoCoordenada representa la informaci\'on perteneciente a cada coordenada en el Mapa. Guardamos si en esta posici\'on hay pokemon y que pokemon, si ya se capturo un pokemon en esta coordenada que lo usamos para saber si quedo un heap no valido. En jugEspe usamos un min heap de $<$Jugador, CantidadPokemonesAtrapados$>$ para cuando se capture un Pokemon poder seleccionar el jugador que lo atrapa en O(log n) porque lo desencolamos del heap. Era necesario esta complejidad para poder cumplir la complejidad de mover. En MovimientosRestantes guardamos la cantidad de movimientos restantes para atrapar el Pokemon.\\
InfoJugador representa la informaci\'on de cada jugador. Aqu\'i guardamos al jugador (para no depender solamente del la posici\'on del vector que algunas veces lo recorremos pero no lo tenemos), si esta conectado, expulsado, sanciones, en pos la posici\'on actual, pokemons atrapados, la posici\'on en el mapa, cantTotalPoke es cantidad total de pokemones que atrapo. En pokemons guardamos un iterador  de lista que se guarda en Game, se explic\'o en (\textbf{**}). En posicionMapa guardamos un iterador a la cola de prioridad (heap) de la coordenada en caso de estar esperando para atrapar un pokemon, esto lo hicimos para poder eliminarlo de forma f\'acil del heap (cuando se mueve, se elimina, etc) y poder cumplir las complejidades de mover.


	\begin{Estructura}{Juego}[Game]
		\begin{Tupla}[Game]
			\tupItem{pokemons}{diccString(pokemon, tupla <cantSalvaje: Nat, cantTotal: Nat>)}
			\tupItem{\\mapa}{Mapa}
			\tupItem{\\jugadores}{Vector(InfoJugador)}
			\tupItem{\\mapaInfo}{Arreglo de Arreglo de InfoCoordenada}
			\tupItem{\\cantidadTotPokémons}{Nat}
			\tupItem{\\coordenadasConPokemons}{Conj(Coordenada)}
			\tupItem{\\coordenadasPokemons}{Dicc(Coordenada, pokemon)}
			\tupItem{\\pokemonsDeJugadores}{Lista(Dicc(pokemon: string, cant: nat))}
		\end{Tupla}
	\end{Estructura}
	
	\begin{Tupla}[InfoJugador]
		\tupItem{jug}{jugador}
		\tupItem{\\conectado}{Bool}
		\tupItem{\\expulsado}{Bool}
		\tupItem{\\sanciones}{Nat}
		\tupItem{\\pos}{Coordenada}
		\tupItem{\\pokemons}{itLista(Dicc(pokemon: string, cant: nat))}
		\tupItem{\\posicionMapa}{itDicc(jugador: Nat, EsperandoCapturar: itColaDePrioridad(cantPokemon)))}
		\tupItem{\\cantTotalPoke}{Nat}
	\end{Tupla}
	
	
	\begin{Tupla}[InfoCoordenada]
		\tupItem{pokemon}{Pokemon}
		\tupItem{\\jugEspe}{ColaDePrioridad(cantPokemon)}
		\tupItem{\\hayPokemon}{Bool}
		\tupItem{\\yaSeCapturo}{Bool}
		\tupItem{\\jugadores}{Dicc(jugador: nat, EsperandoCapturar: itColaDePrioridad(cantPokemon))}
		\tupItem{\\MovimientosRestantes}{Nat}
	\end{Tupla}

\subsubsection{Invariante de representación}

\subsubsection{Predicado de abtraccion}

	\Titulo{Representacion del iterador}
\subsection{Justificacion}

	\begin{Estructura}{itJugador}[iter]
		\begin{Tupla}[iter]
		\tupItem{posicion}{nat}
		\tupItem{vector}{puntero(Vector(infoJugador))}
		\end{Tupla}
	\end{Estructura}
\subsection{Invariante de representacion}

\textbf{Informal}

\textbf{Formal}

\subsection{Predicado de abstraccion}

\end{Representacion}
\subsection{Algoritmos}

\begin{Algoritmos}
\Titulo {Algoritmos del Modulo}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Generadores
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{algorithm}[H]{\textbf{iCrearJuego}(\In {m}{Mapa}) $\to$ res: Game}
	\begin{algorithmic}[1]
		\State coords $\gets$ Coordenadas(m) \Comment O(1)
		\State iter $\gets$ CrearIt(coords) \Comment O(1)
		\State ancho $\gets$ 0 \Comment O(1)
		\State alto $\gets$ 0 \Comment O(1)
		\While{HaySiguiente(iter)} \Comment O($\#$coords)
			\State c $\gets$ Siguiente(iter) \Comment O(1)
			\State Avanzar(iter) \Comment O(1)
			\State \IF Altitud(c) > alto THEN alto $\gets$ Altitud(c) ELSE FI \Comment O(1)
			\State \IF Longitud(c) > ancho THEN ancho $\gets$ Longitud(c) ELSE FI \Comment O(1)
		\EndWhile
		\State infocoor $\gets$ arreglo[ancho] de arreglo[alto] de <Vac\'ia(), Bool, Vac\'ia(), 10> \Comment O(m.ancho * m.alto)
		\State res $\gets$ <Vacio(), m, Vac\'ia(), infocoor, 0, Vac\'ia()> \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(TM)
		\Statex \underline{Justificacion:} Donde TM es el tama\~no del mapa (alto $\times$ ancho)
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iAgregarJugador}(\In {g}{Game}) $\to$ res: itJuego($\sigma$)}
	\begin{algorithmic}[1]
		\State Dicc(pokemon, nat) dicc $\gets$ Vacio() \Comment O(1)
		\State itLista(Dicc(pokemon, cantidad)) it $\gets$ AgregarAtras(g.pokemonsDeJugadores, dicc) \Comment O(1) 
		\State AgregarAtras (g.jugadroes, <false, false, 0, <0, 0>, it, NULL, 0>) \Comment O(longitud(g.jugadores) + copy(tupla))
		\State   itJuego($\sigma$) it $\gets$ CrearIt(g) \Comment O(1)
		\While {it.posicion $<$ Longitud(g.jugadores)} \Comment O(longitud(g.jugadores))
			\State it.posicion $\gets$ it.posicion + 1 \Comment O(1)
		\EndWhile
		\State res $\gets$ it \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(longitud(g.jugadores))
		\Statex \underline{Justificacion:}Agrega un jugador al juego, el costo de copiar la tupla es O(1) porque todas las componentes están vacías, después crea un iterador al principio del vector y lo avanza hasta la última posición donde fue agregado el jugador y lo devuelve. Para hacer esto último tengo que recorrer todo el vector entonces la complejidad final es O(longitud(g.jugadores) + (longitud(g.jugadores) + copiar(tupla))), como dijimos el costo de copiar  
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iAgregarPokemon}(\In {p}{string}, \In {c}{coordenada}, \Inout {g}{game})}
	\begin{algorithmic}[1]
		\State AgregarRapido(g.coordenadasPokemons, c) \Comment O(copiar(c)) = O(1)
		\If{$\neg$Definido(p, g.pokemons)} \Comment O(2$*$|p|) = O(|p|)
			\State Definir(p, <1, 1>, g.pokemons) \Comment O(|P|)
		\Else
			\State Definir(p, <Significado(p, g.pokemons).cantSalvaje +1, Significado(p, g.pokemons).cantTotales +1>, g.pokemons) \Comment O(|p|)
		\EndIf
		\State g.mapaInfo[c].hayPokemon $\gets$ true \Comment O(1)
		\State g.mapaInfo[c].jugEspe $\gets$ Vacio() \Comment O(1)
		\State g.mapaInfo[c].yaSeCapturo $\gets$ flase \Comment O(1)
 		\State g.mapaInfo[c].movimientosRestantes $\gets$ 0 \Comment O(1)
		\State lista(coordenada) lc $\gets$ Vacia() \Comment O(1)
		\State lc $\gets$ CeldasValidas(g, c) \Comment O(1)
		\State AgregarAtras(lc, c) \Comment O(1)
		\State itLista(coordenadas) itCoordenadas $\gets$ CrearIt(lc) \Comment O(1)
		\While{HaySiguiente(itCoordenadas)} \Comment O($\#$(jugadoresEnRadioDeCaptura)*log($\#$(jugadoresEnRadioDeCaptura))
			\State itDicc(jugador, EsperandoCapturar) itJugadores $\gets$ CrearIt(g.mapaInfo[Siguiente(itCoordenadas)].jugadores) \Comment O(1)
			\While {HaySiguiente(itJugadores)} \Comment O($\#$(jugadoresEnRadioDeCaptura)*log($\#$(jugadoresEnRadioDeCaptura))
				\If{SiguienteSignificado(itJugadores) $\neq$ NULL}
					\State Borrar(SiguienteSignificado(itJugadores))				
				\EndIf
				\State itColaPrioridad itCola $\gets$ Encolar(g.mapaInfo[c].jugEspe, g.jugadores[SiguienteClave(itJugadores)].cantTotPoke, SiguienteClave(itJugadores)) \Comment O(log (n), siendo n la cantidad de elementos en el arbol)
				\State SiguienteSignficado(itJugadores) $\gets$ itCola \Comment O(1)
				\State Avanzar(itJugadores) \Comment O(1)
			\EndWhile
			\If {EsVacio?(g.mapaInfo[Siguiente(itCoordena)].jugEspe)}
				\State g.mapaInfo[Siguiente(itCoordena)].yaSeCapturo $\gets$ false \Comment O(1)			
			\EndIf
			\State Avanzar(itCoordenada) \Comment O(1)
		\EndWhile
		\medskip
		\Statex \underline{Complejidad:} O(($\#$(jugadoresEnRadioDeCaptura)*log($\#$(jugadoresEnRadioDeCaptura))) + |P|)
		\Statex \underline{Justificacion:}Primero defino el pokemon en el diccString, si ya estaba sumo un 1 en la cant de pokemons salvajes, sino lo defino con un 1 en cant salvajes y 0 en atrapados, esto me toma |P| siendo P la máxima longitud de una clave del diccionario. Después me armo una lista con las coordenadas en el radio de captura esto toma tiempo constate porque son finitas cordenadas. Luego creo un iterador a esta lista para recorrerla, como tengo finitos elementos recorrerla es constante. Por cada coordenada me creo un it al diccionario de los jugadores en esa coordenada. Los recorro, recorrer a todos los jugadores en el radio es EC siendo EC la máxima cantidad de jugadores esperando capturar un pokemon, y por cada jugador pregunto si su iter a cola de prioridad esta definido (no supimos como hacerlo asi que lo consideramos como un puntero) si lo esta borra lo que esta apuntando, despues encolo el elemento a la cola de prioridad del pokemon, me guardo el iterador que me devuelve encolar, y asi para todos los jugadores de la coordena, despues de salir de este while que toma la cantidad de los jugadores de la coordenada, O($\#$jugadores en la coordenada), y por cada uno lo encolo a la cola eso me toma O(log n)(n la cantidad de elementos de la cola), entonces la complejidad final es O($\#$jugadores en la coordenada * log n). Esto lo hago para todas las coordenadas entonces me queda O($\#$JugadoresEsperandoCapturar * log($\#$JugadoresEsperandoCapturar)), luego antes de avanzar de coordenada, pregunto si el la que estoy parado su cola de prioridad esta vacía, si lo está pongo a false un booleano, este es el caso de que hubo alguna vez un pokemon en esa coordenada. Y despues de salir del while general termine todo entonces la complejidad final es O(($\#$(jugadoresEnRadioDeCaptura)*log($\#$(jugadoresEnRadioDeCaptura))) + |P|) 
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iCeldasValidas}(\In {g}{Game}, \In {c}{coordenada}) $\to$ res: lista(coordenada)}
	\begin{algorithmic}[1]
		\State lista(coordenada) ls $\gets$ Vacia() \Comment O(1)
		\State nat i $\gets$ 4 \Comment O(1)
		\While {i $>$ 0} \Comment O(1)
			\State AgregarAtras(ls, <latitud(c)+i, longitud(c)>) \Comment O(1)
			\State AgregarAtras(ls, <latitud(c)-i, longitud(c)>) \Comment O(1)
			\State AgregarAtras(ls, <latitud(c), longitud(c)+i>) \Comment O(1)
			\State AgregarAtras(ls, <latitud(c), longitud(c)-i>) \Comment O(1)
			\State i $\gets$ i - 1 \Comment O(1)
		\EndWhile
		\State i $\gets$ 3
		\While {i > 0} \Comment O(1)
			\State AgregarAtras(ls, <latitud(c)+3, longitud(c)-(i-1)>) \Comment O(1)
			\State AgregarAtras(ls, <latitud(c)-(i-1), longitud(c)+3>) \Comment O(1)
			\State AgregarAtras(ls, <latitud(c)-3, longitud(c)-(i-1)>) \Comment O(1)
			\State AgregarAtras(ls, <latitud(c)-(i-1), longitud(c)-3>) \Comment O(1)
			\State AgregarAtras(ls, <latitud(c)-3, longitud(c)+(i-1)>) \Comment O(1)
			\State AgregarAtras(ls, <latitud(c)+(i-1), longitud(c)-3>) \Comment O(1)
			\State AgregarAtras(ls, <latitud(c)+3, longitud(c)+(i-1)>) \Comment O(1)
			\State AgregarAtras(ls, <latitud(c)+(i-1), longitud(c)+3>) \Comment O(1)
			\State AgregarAtras(ls, <latitud(c)+(i-1), longitud(c)+2>) \Comment O(1)
			\State AgregarAtras(ls, <latitud(c)+(i-1), longitud(c)+1>) \Comment O(1)
			\State AgregarAtras(ls, <latitud(c)+(i-1), longitud(c)-2>) \Comment O(1)
			\State AgregarAtras(ls, <latitud(c)+(i-1), longitud(c)-1>) \Comment O(1)
			\State AgregarAtras(ls, <latitud(c)-(i-1), longitud(c)-2>) \Comment O(1)
			\State AgregarAtras(ls, <latitud(c)-(i-1), longitud(c)-1>) \Comment O(1)
			\State AgregarAtras(ls, <latitud(c)-(i-1), longitud(c)+2>) \Comment O(1)
			\State AgregarAtras(ls, <latitud(c)-(i-1), longitud(c)+1>) \Comment O(1)			
			\State i $\gets$ i -1 \Comment O(1) 
		\EndWhile
		\State itLista(coordenada) it $\gets$ CrearIt(ls) \Comment O(1)		
		\While {HaySiguiente(it)} \Comment O(1)
			\If{PosExistente (Siguiente(it), g.mapa)} \Comment O(1)
				\State Avanzar(it) \Comment O(1) 
			\Else
				\State EleminarSiguiente(it) \Comment O(1)			
			\EndIf
		\EndWhile
		\State res $\gets$ ls \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1))
		\Statex \underline{Justificacion:}Como me estoy fijando un numero finito de coordenadas, y la cantidad que veo no varia porque no depende de la entrada, puedo decir que toma O(1) ver todas las celdas, luego recorro la lista para ver cuales son válidas y cuales no, que como son una cantidad constatnte de celdas recorrer la lista tambien es constante
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iAgregarJugador}(\In {g}{Game}) $\to$ res: itJuego($\sigma$)}
	\begin{algorithmic}[1]
		\State Dicc(pokemon, nat) dicc $\gets$ Vacio() \Comment O(1)
		\State itLista(Dicc(pokemon, cantidad)) it $\gets$ AgregarAtras(g.pokemonsDeJugadores, dicc) \Comment O(1) 
		\State AgregarAtras (g.jugadroes, <false, false, 0, <0, 0>, it, NULL, 0>) \Comment O(longitud(g.jugadores) + copy(tupla))
		\State   itJuego($\sigma$) it $\gets$ CrearIt(g) \Comment O(1)
		\While {it.posicion $<$ Longitud(g.jugadores)} \Comment O(longitud(g.jugadores))
			\State it.posicion $\gets$ it.posicion + 1 \Comment O(1)
		\EndWhile
		\State res $\gets$ it \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(longitud(g.jugadores))
		\Statex \underline{Justificacion:}Agrega un jugador al juego, el costo de copiar la tupla es O(1) porque todas las componentes están vacías, después crea un iterador al principio del vector y lo avanza hasta la última posición donde fue agregado el jugador y lo devuelve. Para hacer esto último tengo que recorrer todo el vector entonces la complejidad final es O(longitud(g.jugadores) + (longitud(g.jugadores) + copiar(tupla))), como dijimos el costo de copiar  
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iMoverse}(\In {j}{jugador}, \In {c}{coordenada}, \Inout {g}{Game})}
	\begin{algorithmic}[1]
		\If {SiguienteSignificado(g.jugadores[j].posicionMapa) $\neq$ NULL} \Comment O(1)
				\State Borrar(SiguienteSignificado(g.jugadores[j].posicionMapa)) \Comment O(1)
				\State g.jugadores[J].posicionMapa $=$ NULL \Comment O(1)
		\EndIf		
		\If{distEuclidia(c, g.jugadores[j].pos) $>$ 100 $\vee$ $\neg$(hayCamino(c,g.jugadores[j].pos, g.mapa))} \Comment O(1)
			\State g.jugadores[j].sanciones $\gets$ g.jugadores[j].sanciones +1 \Comment O(1)
			\If(g.jugadores[j].sanciones $\geq$ 4) \Comment O(1)
				\State g.jugadores[j].expulsado $\gets$ true \Comment O(1)			
			\EndIf
		\EndIf
		\If {g.jugadores[j].expulsado $=$ true}
			\State g.cantidadTotPokemons $\gets$ g.cantidadTotPokemons - g.jugadores[j].cantTotalPoke \Comment O(1)
			\State itDicc(pokemon, nat) itPokemons $\gets$ CrearIt(Siguiente(g.jugadores[j].pokemons))
			\While{HaySiguiente(itPokemons)} \Comment O($\#$(pokemonsDicc)*|P|)
				\State Significado(g.pokemones, SiguienteClave(itPokemons)).cantTotal - SiguienteSignificado(itPokemons) \Comment O(|P|)
				\If {Significado(g.pokemones, SiguienteClave(it.Pokemons)).cantTotal = 0}
					\State Borrar(g.pokemons, SiguienteClave(it.Pokemons)) \Comment O(|P|)					\EndIf				
				\State EliminarSiguiente(itPokemons) \Comment O(1)		
			\EndWhile
			\State EliminarSiguiente(g.jugadores[j].pokemons) \Comment O(1)
			\State g.jugadores[j].pokemons $\gets$ NULL \Comment O(1)
			\State g.jugadores[j].cantTotalPoke $\gets$ 0 \Comment O(1)
		\Else
			\State lista(coordenada) lc $\gets$ CeldasValidas(g.jugadores[j].pos, g.mapa) \Comment O(1)
			\State itLista(coordenada) itCoordenada $\gets$ lc \Comment O(1)
			\While {HaySiguiente(itCoordenada)} \Comment O(1)
				\If {g.mapaInfo[Siguiente(itCoordenada)].hayPokemon $=$ false} \Comment O(1)
					\State EleminarSiguiente(itCoordenada) \Comment O(1)
				\EndIf
			\EndWhile
			\State g.jugadores[j].pos $\gets$ c \Comment O(1)
			\If{itCoordenada $\neq$ NULL}
				\State itDicc(jugador, itColaPrioridad(cantidadPokemons)) itDicc $\gets$ DefinirRapido(g.mapaInfo[c].jugadores, j, Encolar(g.mapaInfo[Siguiente(itCoordenada)].jugEspe, g.jugadores[j].cantTotalPoke, j)) \Comment O(log ($\#$elemEnLaCola))
				\State g.jugadores[j].posicionMapa $\gets$ itDicc \Comment O(1)
			\Else
				\State itDicc(jugador, itColaPrioridad(cantidadPokemons)) itDicc $\gets$ DefinirRapido(g.mapaInfo[c].jugadores, j, NULL)	\Comment O(1)		
				\State g.jugadores[j].posicionMapa $\gets$ itDicc
			\EndIf
		\EndIf
		\State itDicc(coordenada, pokemons) itPokemons $\gets$ g.coordenadasPokemons \Comment O(1)
		
		\medskip
		\Statex \underline{Complejidad:} 
		\Statex \underline{Justificacion:}
	\end{algorithmic}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OBSERVADORES BASICOS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{algorithm}[H]{\textbf{iMapa}(\In {g}{Game}) $\to$ res: mapa}
	\begin{algorithmic}[1]
		\State res $\gets$ g.mapa \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:} Devuelve la instancia de mapa que tenemos guardada
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iJugadores}(\In {g}{Game}) $\to$ res: conj(jugador)}
	\begin{algorithmic}[1]
		\State res $\gets$ CrearIt(g) \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:} Crea un iterador a jugadores que tiene orden de 1 y lo devuelve
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iEstaConectado}(\In {j}{jugador}, \In {g}{Game}) $\to$ res: conj(jugador)}
	\begin{algorithmic}[1]
		\State res $\gets$ g.jugadores[j].conectado \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:} Es una asignaci\'on, un acceso de O(1) a un vector por el id del jugador y ah\'i guardamos una tupla con informaci\'on del jugador, en particular si est\'a \'o no conectado
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iSanciones}(\In {j}{jugador}, \In {g}{Game}) $\to$ res: nat}
	\begin{algorithmic}[1]
		\State res $\gets$ g.jugadores[j].sanciones \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:} Es una asignaci\'on, un acceso de O(1) a un vector por el id del jugador y ah\'i guardamos una tupla con informaci\'on del jugador, en particular la cantidad de sanciones que tiene
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iPosicion}(\In {j}{jugador}, \In {g}{Game}) $\to$ res: coordenada}
	\begin{algorithmic}[1]
		\State res $\gets$ g.jugadores[j].pos \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:} Es una asignaci\'on, un acceso de O(1) a un vector por el id del jugador y ah\'i guardamos una tupla con informaci\'on del jugador, en particular la posici\'on actual del jugador cuando esta conectado
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iPokemons}(\In {j}{jugador}, \In {g}{Game}) $\to$ res: itDicc($<Pokemon, cantidad>$)}
	\begin{algorithmic}[1]
		\State res $\gets$ CrearIt(Siguiente(g.jugadores[j].pokemons)) \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:} Dentro de jugadores guardamos un iterador a Dicc(<Pokemon, Cantidad>) que est\'a guardado en Game. De esta forma en el vector de jugadores guardamos estructuras simples de copiar, esto era necesario por la complejidad del agregar jugador (ver AgregarJugador). Tanto la asignaci\'on y la creaci\'on del iterador y el siguiente del iterador de lista son todos O(1)
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iExpulsados}(\In {g}{Game}) $\to$ res: conj(jugador)}
	\begin{algorithmic}[1]
		\State res $\gets$ Vac\'io() \Comment O(1)
		\State tam $\gets$ Longitud(g.jugadores) \Comment O(1)
		\State \textbf{for} n $\gets$ 0 \textbf{to} tam \Comment O(J)
		\State \,\,\,\,AgregarRapido(res, g.jugadores[n].jug) \Comment O(copy(jugador))
		\medskip
		\Statex \underline{Complejidad:} O(J)
		\Statex \underline{Justificacion:} El for se ejecuta J veces y como jugador es un nat, el costo de copiarlo es O(1) entonces la complejidad es O(J)
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iPosConPokemons}(\In {g}{Game}) $\to$ res: conj(coordenada)}
	\begin{algorithmic}[1]
		\State res $\gets$ g.coordenadasConPokemons \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:} Devolvemos el conjunto de coordenadas con Pokemones. La asignaci\'on al ser de un tipo \textbf{no} primitivo tanto res como g.coordenadasConPokemons referencian a la misma estructura f\'isica (del apunte de dise\~no)
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iPokemonEnPos}(\In {c}{coordenada}, \In {g}{Game}) $\to$ res: conj(coordenada)}
	\begin{algorithmic}[1]
		\State res $\gets$ g.mapainfo[Altitud(c)][Longitud(c)].pokemon \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:} El acceso a mapainfo que es una matriz es O(1) y tenemos solo una asignaci\'on
	\end{algorithmic}
\end{algorithm}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Iterador
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\Titulo {Algoritmos del iterador}

\begin{algorithm}[H]{\textbf{iCrearIt}(\In {g}{game}) $\to$ res: iter))}
	\begin{algorithmic}[1]
		\State res $\gets$ <0, puntero(g.jugadores)> \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:}Crea un iterador al princio del vector, solo 
		realiza una asignación  
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iHayMas?}(\In {it}{iter}) $\to$ res: bool))}
	\begin{algorithmic}[1]
		\State bool b $\gets$ false
		\State nat i $\gets$ it.posicion \Comment O(1)
		\While {i $<$ it.vector$\to$ longitud $\wedge$ $\neg$b} \Comment O(longitud(v))
			\If {it.vector$\to$ elementos[i].expulsado $=$ false} \Comment O(1)
				\State b $\gets$ true \Comment O(1)
			\EndIf
		\State i $\gets$ i +1 \Comment O(1)		
		\EndWhile
		\State res $\gets$ b
		\medskip
		\Statex \underline{Complejidad:} O(longitud(v))
		\Statex \underline{Justificacion:}En el peor de lo casos hay que recorrer todo el vector para saber si existe otro elemento

\end{algorithmic}
\end{algorithm}	
		
\begin{algorithm}[H]{\textbf{iAvanzar}(\Inout {it}{iter})}
	\begin{algorithmic}[1]
		\State bool b $\gets$ false
		\State nat i $\gets$ it.posicion \Comment O(1)
		\While {i $<$ it.vector$\to$ longitud $\wedge$ $\neg$b} \Comment O(longitud(v))
			\If {it.vector$\to$ elementos[i].expulsado $=$ false} \Comment O(1)
				\State b $\gets$ true \Comment O(1)
			\EndIf
		\State i $\gets$ i +1 \Comment O(1)		
		\EndWhile
		\State it.posicion $\gets$ (i-1) \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(longitud(v))
		\Statex \underline{Justificacion:}Recorre el vector y para en el primer elemento válido, que existe por la precondición de la función, luego actualiza la posición del iterador  
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iActual}(\In {it}{iter}) $\to$ res: nat}
	\begin{algorithmic}[1]
		\State res $\gets$ it.posicion \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:}Devuelve la id del jugador que apunta el iterador  
	\end{algorithmic}
\end{algorithm}
	
\begin{algorithm}[H]{\textbf{iSiguientes}(\In {it}{iter}) $\to$ res: lista(jugadores)))}
	\begin{algorithmic}[1]
		\State lista(nat) ls $\gets$ Vacia() \Comment O(1), crea una lista vacia
		\State nat i $\gets$ it.posicion \Comment O(1)
		\While {i $<$ it.vector$\to$ longitud} \Comment O(longitud(v))
			\If {it.vector$\to$ elementos[i].expulsado $=$ false} \Comment O(1)
				\State AgregarAtras(ls, it.posicion) \Comment O(1)
			\EndIf
		\State i $\gets$ i +1 \Comment O(1)		
		\EndWhile
		\State res $\gets$ ls \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(longitud(v))
		\Statex \underline{Justificacion:}Para devolver una lista con los elementos que quedan por recorrer, recorro todo el vector viendo que elementos son válidos y si un elemento es válido lo agrego a una lista.
	\end{algorithmic}
\end{algorithm}

\end{Algoritmos}
