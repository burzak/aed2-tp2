\section{Juego}

\subsection{Interfaz}

\parbox {1,7cm}{{\bf Género}} juego \\
{\bf se explica con:}  \tadNombre{Mapa}, \tadNombre{Conjunto ($\sigma$)} , \tadNombre{Secuencia($\sigma$)}, \tadNombre{Bool}, \tadNombre{Pokemon}, \tadNombre{Jugador}, \tadNombre{Nat}\\
\medskip

\parbox {1,5cm}{\bf{Operaciones básicas}}\\

\InterfazFuncion{CrearJuego}{\In {m}{mapa}}{juego}
{res $\igobs$ crearJuego(m)}
[O(1)]
[Creo un nuevo juego tomando un mapa]\\

\InterfazFuncion{AgregarPokemon}{\In {p}{pokemon}, \In {c}{coordenada}, \Inout {g}{juego}}{}
[puedoAgregarPokemon(c, j) $\wedge$ g $\igobs$ g$_0$]
{g = agregarPokemon(p, c, g$_0$)}
[O(|P| + EC*log(EC)), siendo |P| es el nombre más largo para un pokemon y EC es la máxima cantidad de jugadores esperando capturar un pokemon]
[Agrego un pokemon al juego]\\

\InterfazFuncion{AgregarJugador}{\In {g}{juego}}{it(jugador)}
[g $\igobs$ g$_0$]
{g = agregarJugador(g$_0$)}
[O(J), Siendo J la cantidad de jugadores que fueron agregados al juego]
[Agrega un jugador al juego]\\

\InterfazFuncion{Conectarse}{\In {j}{jugador}, \In {c}{coordenada}, \Inout {g}{juego}}{}
[g $\igobs$ g$_0$ $\wedge$ j $\in$ jugadores(g) $\yluego$ $\neg$estaConectado(j, g) $\wedge$ posExistente(c, mapa(g))]
{g = conectarse(g$_0$)}
[O(log(EC)), siendo EC la máxima cantidad de jugadoes esperando capturar un pokémon]
[Conecta un jugador al juego, con todo lo que esto implica]\\

\InterfazFuncion{Desconectarse}{\In {j}{jugador}, \Inout{g}{juego}}{}
[g $\igobs$ g$_0$ $\wedge$ j $\in$ jugadores(g) $\yluego$ estaConectado(j, g)]
{g = desconectarse(j, g$_0$)}
[O(log(EC)), siendo EC la máxima cantidad de jugadoes esperando capturar un pokémon]
[Desconecta al jugador j del juego]\\

\InterfazFuncion{Moverse}{\In {j}{jugador}, \In {c}{coordenada}, \Inout {g}{juego}}{}
[g $\igobs$ g$_0$ $\wedge$ j $\in$ jugadores(g) $\yluego$ estaConectado(j, g) $\wedge$ posExistente(c, mapa(g))]
{g = moverse(j, c, g$_0$)}
[O((PS + PC)*|P|+log(EC)), siendo PS la cantidad de pokemons salvajes, PC la máxima cantidad de pokemon capturados por un jugador]
[Mueve un jugador en el mapa, verifica si hay una captura de pokémon, y para el jugador movido verifica si cometió alguna infracción]\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OBSERVADORES BASICOS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\InterfazFuncion{Mapa}{\In {g}{juego}}{Mapa}
{res $\igobs$ mapa(g)}
[O(1)]
[Devuelve la instancia de mapa que tenemos guardada]
\\

\InterfazFuncion{Jugadores}{\In {g}{juego}}{Conj(Jugador)}
{res $\igobs$ jugadores(g)}
[O(1)]
[Devuelve la instancia de mapa que tenemos guardada]
\\

\InterfazFuncion{EstaConectado}{\In {j}{Jugador}, \In {g}{juego}}{Bool}
[j $\in$ jugadores(g)]
{res $\igobs$ estaConectado(g)}
[O(1)]
[Dice si un jugador esta conectado o no]
\\

\InterfazFuncion{Sanciones}{\In {j}{Jugador}, \In {g}{juego}}{Nat}
[j $\in$ jugadores(g)]
{res $\igobs$ sanciones(g)}
[O(1)]
[La cantidad de sanciones que tiene un jugador]
\\

\InterfazFuncion{Posicion}{\In {j}{Jugador}, \In {g}{juego}}{Coordenada}
[j $\in$ jugadores(g) $\impluego$ estaConectado(j, g)]
{res $\igobs$ posicion(j, g)}
[O(1)]
[Posici\'on actual del jugador cuando se encuentra conectado]
\\

\InterfazFuncion{Pokemons}{\In {j}{Jugador}, \In {g}{juego}}{Iter(<Pokemon, Nat>)}
[j $\in$ jugadores(g)]
{res $\igobs$ pok\'emons(j, g)}
[O(1)]
[Devuelve un iterador <Pokemon, Nat>]
\\

\InterfazFuncion{Expulsados}{\In {g}{juego}}{Conj(Jugador)}
{res $\igobs$ expulsados(g)}
[O(J)]
[Conjunto de jugadores expulsados del juego]
\\

\InterfazFuncion{PosConPokemons}{\In {g}{juego}}{Conj(coor)}
{res $\igobs$ posConPok\'emons(g)}
[O(1)]
[Conjunto de coordenadas con Pok\'emones]
\\

\InterfazFuncion{PokemonEnPos}{\In {c}{Coordenada}, \In {g}{juego}}{Pokemon}
[c $\in$ posConPokemons(g)]
{res $\igobs$ pokemonEnPos(c, g)}
[O(1)]
[Devolvemos el Pokemon en la Coordenada]
\\

\InterfazFuncion{CantMovimientosParaCaptura}{\In {c}{Coordenada}, \In {g}{juego}}{Nat}
[c $\in$ posConPokemons(g)]
{res $\igobs$ cantMovimientosParaCaptura(c, g)}
[O(1)]
[Cantidad de movimientos restantes para que un Pokemon sea capturado]
\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OTRAS OPERACIONES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\InterfazFuncion{JugadoresConectados}{\In {g}{juego}}{Conj(Jugador)}
{res $\igobs$ jugadoresConectados(g)}
[O(J)]
[Conjunto de jugadores conectados]
\\

\InterfazFuncion{PuedoAgregarPokemon}{\In {c}{Coordenada}, \In {g}{juego}}{Bool}
{res $\igobs$ puedoAgregarPokemon(g)}
[O(?)]
[Devuelve True si se puede agregar un Pokemon en la coordenada]
\\

\InterfazFuncion{HayPokemonCercano}{\In {c}{Coordenada}, \In {g}{juego}}{Bool}
{res $\igobs$ hayPokemonCercano(c, g)}
[O(?)]
[Devuelve True s\'i y solo s\'i hay un Pokemon a radio 4 de la Coordenada]
\\

\InterfazFuncion{IndiceRareza}{\In {p}{Pokemon}, \In {g}{Juego}}{nat}
[p $\in$ pokemons]
{res $\igobs$ indiceRareza(p, g)}
[O(|s|)]
[Devuelve el índice de rareza del pokemon]
\\

\InterfazFuncion{CantPokemonsTotales}{\In {g}{Juego}}{nat}
{res $\igobs$ cantPokemonsTotales(g)}
[O(1)]
[Devuelve la cantidad de pokemons existentes, tanto salvajes como capturados.]
\\

\InterfazFuncion{PosPokemonCercano}{\In {c}{Coordenada}, \In {g}{Juego}}{Coordenada}
[hayPokemonCercano(c,g)]
{res $\igobs$ posPokemonCercano(c, g)}
[O(1)]
[Devuelve True s\'i y solo s\'i hay un Pokemon a radio 4 de la Coordenada]



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ITERADOR
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\bf{Operaciones del iterador}\\

\InterfazFuncion{CrearIt}{\In {g}{game}}{itJugador}
{res = CrearItUni(v)}
[O(1)]
[Crea un iterador unidireccional no modificable al principio del vector, no necesariamente es un elemento válido por ende no se puede usar Actual sin Avanzar]
[]\\

\InterfazFuncion{HayMas?}{\In {it}{itJugador}}{bool}
{res $\igobs$ HayMas?(it)}
[O(n), siendo n la cantidad de elementos del vector]
[Devuelve true si y solo si quedan elementos para avanzar]\\

\InterfazFuncion{Avanzar}{\Inout {it}{itJugador}}{}
[HayMas?(it) $\wedge$ it $\igobs$ it$_0$]
{it $\igobs$ Avanzar(it$_0$)}
[O(n), siendo n la cantidad de elementos del vector]
[Avanza el iterador al próximo elemento del vector]\\

\InterfazFuncion{Actual}{\In {it}{itJugador}}{Nat}
[HayMas?(it)]
{res $\igobs$ Actual(it)}
[O(1)]
[Devuelve el Id apuntado por el iterador]
[res no es modificable porque el iterador no es modificable]\\

\InterfazFuncion{Siguientes}{\In {it}{itJugador)}}{lista($\sigma$)}
{res $\igobs$ Siguientes(it)}
[O(n), siendo n la cantidad de elementos del vector]
[Devuelve los elementos del vector posteriores al iterador, puede no haber ninguno]\\

\ttitulo{No exportable, operaciones auxiliares}

\InterfazFuncion{CeldasValidas}{\In {g}{juego}, \In {c}{coordenada}}{lista(coordenadas)}
[c $\in$ coordenadas(mapa(g))]
{($\forall c_1$: coordenada)(esta?($c_1$, res)$\impluego$(distEuclidea($c_1$, c)$\leq$2  $\wedge$ posExistente($c_1$, mapa(g)))}
[Devuelve una lista con las coordenas a una distancia no mayor de 2 de la coordenada c y que ademas existan en el mapa del juego]

\begin{Representacion}
\ttitulo{ del modulo}

\subsubsection{Justificación}
Game representa un Juego.\\
En pokemons guardamos un diccionario sobre Trie y la clave es el Pokemon (string). Esto nos permite encontrar un pokemon en |P|. En el diccionario guardamos la cantidad de pokemones salvajes que hay y cuantos hubieron de ese tipo en total para poder calcular la rareza del pokemon en O(|P|) junto con cantidadTotPokemons que es el total de los Pokemons en el juego.
En mapa guardamos el mapa con el que se crea el Juego.\\
coordenadasConPokemons guardamos un conjunto de Coordenadas donde hay pokemones para poder devolver en posConPok\'emons en O(1).
En jugadores de game guardamos un vector de InfoJugador (ver m\'as abajo). Como en InfoCoordenada guardamos una lista de jugadores en cada coordenada y cuando expulsamos un jugador debemos borrar de forma eficiente en esa lista guardamos un iterador al jugador en diccionario para poder cumplir con los ordenes de mover.\\
mapainfo es una matriz de InfoCoordenadas donde cada dimensi\'on es la latitud y longitud de una coordenada.\\
cantidadTotPokemones guardamos el total de pokemones del juego.\\
coordenaadasPokemons es un diccionario $<$Coordenada, Pokemon$>$ donde guardamos el Pokemon que cada coordenada del Mapa tiene.\\
pokemonsDeJugadores es una lista donde guardamos los Pokemones que atrapó cada jugador. (\textbf{**}) Esto lo tuvimos que guardar fuera de InfoJugador porque ten\'iamos un problema de complejidad al agregar un jugador nuevo. Como usabamos un Vector de jugadores el agregar es O(J + copy($\alpha$)) y guardar los Pokemones que atrapo el jugador hacía que el copy no fuera O(1), entonces guardamos un iterador a esta lista en InfoJugador.\\
InfoCoordenada representa la informaci\'on perteneciente a cada coordenada en el Mapa. Guardamos si en esta posici\'on hay pokemon y que pokemon, si ya se capturo un pokemon en esta coordenada que lo usamos para saber si quedo un heap no valido. En jugEspe usamos un min heap de $<$Jugador, CantidadPokemonesAtrapados$>$ para cuando se capture un Pokemon poder seleccionar el jugador que lo atrapa en O(log n) porque lo desencolamos del heap. Era necesario esta complejidad para poder cumplir la complejidad de mover. En MovimientosRestantes guardamos la cantidad de movimientos restantes para atrapar el Pokemon.\\
InfoJugador representa la informaci\'on de cada jugador. Aqu\'i guardamos al jugador (para no depender solamente del la posici\'on del vector que algunas veces lo recorremos pero no lo tenemos), si esta conectado, expulsado, sanciones, en pos la posici\'on actual, pokemons atrapados, la posici\'on en el mapa, cantTotalPoke es cantidad total de pokemones que atrapo. En pokemons guardamos un iterador  de lista que se guarda en Game, se explic\'o en (\textbf{**}). En posicionMapa guardamos un iterador a la cola de prioridad (heap) de la coordenada en caso de estar esperando para atrapar un pokemon, esto lo hicimos para poder eliminarlo de forma f\'acil del heap (cuando se mueve, se elimina, etc) y poder cumplir las complejidades de mover.


	\begin{Estructura}{Juego}[Game]
		\begin{Tupla}[Game]
			\tupItem{pokemons}{diccString(pokemon, tupla <cantSalvaje: Nat, cantTotal: Nat>)}
			\tupItem{\\mapa}{Mapa}
			\tupItem{\\jugadores}{Vector(InfoJugador)}
			\tupItem{\\mapaInfo}{Arreglo de Arreglo de InfoCoordenada}
			\tupItem{\\cantidadTotPokémons}{Nat}
			\tupItem{\\coordenadasConPokemons}{Conj(Coordenada)}
			\tupItem{\\pokemonsDeJugadores}{Lista(DiccString(pokemon: string, cant: nat))}
		\end{Tupla}
	\end{Estructura}
	
	\begin{Tupla}[InfoJugador]
		\tupItem{jug}{jugador}
		\tupItem{\\conectado}{Bool}
		\tupItem{\\expulsado}{Bool}
		\tupItem{\\sanciones}{Nat}
		\tupItem{\\pos}{Coordenada}
		\tupItem{\\pokemons}{itLista(Dicc(pokemon: string, cant: nat))}
		\tupItem{\\posicionMapa}{itDicc(jugador: Nat, EsperandoCapturar: itColaDePrioridad(cantPokemon)))}
		\tupItem{\\cantTotalPoke}{Nat}
	\end{Tupla}
	
	
	\begin{Tupla}[InfoCoordenada]
		\tupItem{pokemon}{Pokemon}
		\tupItem{\\jugEspe}{ColaDePrioridad(cantPokemon)}
		\tupItem{\\hayPokemon}{Bool}
		\tupItem{\\yaSeCapturo}{Bool}
		\tupItem{\\jugadores}{Dicc(jugador: nat, EsperandoCapturar: itColaDePrioridad(cantPokemon))}
		\tupItem{\\MovimientosRestantes}{Nat}
	\end{Tupla}

\subsubsection{Invariante de representación}

\bf{Informal}

(1)Para todos los pokemons de un jugador dado, estos existen en el diccionario pokemons del juego y ademas la cantidad de los mismos es menor o igual a la cantidad total definida en el diccionario de pokemon del juego\\

(2)CantidadTotalPokemons del juego es igual a la suma de la cantTotal de cada clave del dicc Pokemons\\

(3)Tanto mapa como mapaInfo toman la coordenada con el alto mas grande y el ancho mas grande para definir su tamaño\\

(4)Para toda coordenada en coordenadaConPokemon, existe un pokemon cuya cantSalvaje es 1. Dicho de otra manera la suma de la cantidad de coordenadas es igual a la suma de pokemons libres del dicc Pokemons del juego, para toda coordenada del conj existe una relacion con un pokemon del dicc\\

(5)Toda coordenada donde esta un jugador (infoJugador.pos) esa coordenada existe en mapa y en mapaInfo\\

(6)La parte de la tupla jug en InfoJugador corresponde con el índice del vector jugadores por el cual accedo a esa tupla\\

(7)Para todo elemento de la colaDePrioridad de infoCoordenada, para todo nodo de la cola existe un elemento en el dicc Jugadores de la misma estructura. Además para cada elemento en el dicc jugadores de infoCoordenada, para cualquier coordenada, existe un elemento en el vector Jugadores (jugador no expulsado)\\

(8)Para toda infoCoordenada el pokemon existe en el diccPokemon del juego y ademas la coordenada por la cual se filtra el arreglo de arreglos mapaInfo esta en coordenadaConPokemons \\

(9)Para todo elemento de la lista de pokemons de jugadores existe un jugador (no expulsado) para el cual se corresponde, ademas la suma de la cant de todas las claves del diccionario es igual a CantTotalPoke de infoJugador para ese jugador\\

(10)La coordenada del jugador se corresponde con PosicionMapa de infoJugador\\

\subsubsection{Predicado de abtraccion}

\ttitulo{Representacion del iterador}

\subsection{Justificacion}
	El objetivo del iterador era poder devolver un iterador a la lista de jugadores en O(1) pudiendo siguiente no ser O(1). Creamos el iterados ya que en la lista de jugadores guardamos los jugadores que est\'an jugando como los expulsados y con el iterador recorremos los jugadores no expulsado. Guardamos la ultima posici\'on donde estamos paradon con y el puntero al Vector real de los jugadores
	
	\begin{Estructura}{itJugador}[iter]
		\begin{Tupla}[iter]
		\tupItem{posicion}{nat}
		\tupItem{vector}{puntero(Vector(infoJugador))}
		\end{Tupla}
	\end{Estructura}
\subsection{Invariante de representacion}

\textbf{Informal}
(1)Posicion no puede ser mayor a la longitud del vector
(2)Tiene que cumplir el invariante de vector
(3)Posicion existe como indice del vector

\subsection{Predicado de abstraccion}

\end{Representacion}
\subsection{Algoritmos}

\begin{Algoritmos}
\ttitulo { del Modulo}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Generadores
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{algorithm}[H]{\textbf{iCrearJuego}(\In {m}{Mapa}) $\to$ res: Game}
	\begin{algorithmic}[1]
		\State coords $\gets$ Coordenadas(m) \Comment O(1)
		\State iter $\gets$ CrearIt(coords) \Comment O(1)
		\State ancho $\gets$ 0 \Comment O(1)
		\State alto $\gets$ 0 \Comment O(1)
		\While{HaySiguiente(iter)} \Comment O($\#$coords)
			\State c $\gets$ Siguiente(iter) \Comment O(1)
			\State Avanzar(iter) \Comment O(1)
			\State \IF Altitud(c) > alto THEN alto $\gets$ Altitud(c) ELSE FI \Comment O(1)
			\State \IF Longitud(c) > ancho THEN ancho $\gets$ Longitud(c) ELSE FI \Comment O(1)
		\EndWhile
		\State infocoor $\gets$ arreglo[ancho] de arreglo[alto] de <Vac\'ia(), Bool, Vac\'ia(), 10> \Comment O(m.ancho * m.alto)
		\State res $\gets$ <Vacio(), m, Vac\'ia(), infocoor, 0, Vac\'ia()> \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(TM)
		\Statex \underline{Justificacion:} Donde TM es el tama\~no del mapa (alto $\times$ ancho)
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iAgregarJugador}(\In {g}{Game}) $\to$ res: itJuego($\sigma$)}
	\begin{algorithmic}[1]
		\State Dicc(pokemon, nat) dicc $\gets$ Vacio() \Comment O(1)
		\State itLista(Dicc(pokemon, cantidad)) it $\gets$ AgregarAtras(g.pokemonsDeJugadores, dicc) \Comment O(1) 
		\State AgregarAtras (g.jugadroes, <false, false, 0, <0, 0>, it, NULL, 0>) \Comment O(longitud(g.jugadores) + copy(tupla))
		\State   itJuego($\sigma$) it $\gets$ CrearIt(g) \Comment O(1)
		\While {it.posicion $<$ Longitud(g.jugadores)} \Comment O(longitud(g.jugadores))
			\State it.posicion $\gets$ it.posicion + 1 \Comment O(1)
		\EndWhile
		\State res $\gets$ it \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(longitud(g.jugadores))
		\Statex \underline{Justificacion:}Agrega un jugador al juego, el costo de copiar la tupla es O(1) porque todas las componentes están vacías, después crea un iterador al principio del vector y lo avanza hasta la última posición donde fue agregado el jugador y lo devuelve. Para hacer esto último tengo que recorrer todo el vector entonces la complejidad final es O(longitud(g.jugadores) + (longitud(g.jugadores) + copiar(tupla))), como dijimos el costo de copiar  
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iAgregarPokemon}(\In {p}{string}, \In {c}{coordenada}, \Inout {g}{game})}
	\begin{algorithmic}[1]
		\State AgregarRapido(g.coordenadasPokemons, c) \Comment O(copiar(c)) = O(1)
		\If{$\neg$Definido(p, g.pokemons)} \Comment O(2$*$|p|) = O(|p|)
			\State Definir(p, <1, 1>, g.pokemons) \Comment O(|P|)
		\Else
			\State Definir(p, <Significado(p, g.pokemons).cantSalvaje +1, Significado(p, g.pokemons).cantTotales +1>, g.pokemons) \Comment O(|p|)
		\EndIf
		\State g.mapaInfo[c].hayPokemon $\gets$ true \Comment O(1)
		\State g.mapaInfo[c].jugEspe $\gets$ Vacio() \Comment O(1)
		\State g.mapaInfo[c].yaSeCapturo $\gets$ flase \Comment O(1)
 		\State g.mapaInfo[c].movimientosRestantes $\gets$ 0 \Comment O(1)
 		\State g.mapaInfo[c].pokemon $\gets$ p \Comment O(1)
		\State lista(coordenada) lc $\gets$ Vacia() \Comment O(1)
		\State lc $\gets$ CeldasValidas(g, c) \Comment O(1)
		\State AgregarAtras(lc, c) \Comment O(1)
		\State itLista(coordenadas) itCoordenadas $\gets$ CrearIt(lc) \Comment O(1)
		\While{HaySiguiente(itCoordenadas)} \Comment O($\#$(jugadoresEnRadioDeCaptura)*log($\#$(jugadoresEnRadioDeCaptura))
			\State itDicc(jugador, EsperandoCapturar) itJugadores $\gets$ CrearIt(g.mapaInfo[Siguiente(itCoordenadas)].jugadores) \Comment O(1)
			\While {HaySiguiente(itJugadores)} \Comment O($\#$(jugadoresEnRadioDeCaptura)*log($\#$(jugadoresEnRadioDeCaptura))
				\If{SiguienteSignificado(itJugadores) $\neq$ NULL}
					\State Borrar(SiguienteSignificado(itJugadores))				
				\EndIf
				\State itColaPrioridad itCola $\gets$ Encolar(g.mapaInfo[c].jugEspe, g.jugadores[SiguienteClave(itJugadores)].cantTotPoke, SiguienteClave(itJugadores)) \Comment O(log (n), siendo n la cantidad de elementos en el arbol)
				\State SiguienteSignficado(itJugadores) $\gets$ itCola \Comment O(1)
				\State Avanzar(itJugadores) \Comment O(1)
			\EndWhile
			\If {EsVacio?(g.mapaInfo[Siguiente(itCoordena)].jugEspe)}
				\State g.mapaInfo[Siguiente(itCoordena)].yaSeCapturo $\gets$ false \Comment O(1)			
			\EndIf
			\State Avanzar(itCoordenada) \Comment O(1)
		\EndWhile
		\medskip
		\Statex \underline{Complejidad:} O(($\#$(jugadoresEnRadioDeCaptura)*log($\#$(jugadoresEnRadioDeCaptura))) + |P|)
		\Statex \underline{Justificacion:}Primero defino el pokemon en el diccString, si ya estaba sumo un 1 en la cant de pokemons salvajes, sino lo defino con un 1 en cant salvajes y 0 en atrapados, esto me toma |P| siendo P la máxima longitud de una clave del diccionario. Después me armo una lista con las coordenadas en el radio de captura esto toma tiempo constate porque son finitas cordenadas. Luego creo un iterador a esta lista para recorrerla, como tengo finitos elementos recorrerla es constante. Por cada coordenada me creo un it al diccionario de los jugadores en esa coordenada. Los recorro, recorrer a todos los jugadores en el radio es EC siendo EC la máxima cantidad de jugadores esperando capturar un pokemon, y por cada jugador pregunto si su iter a cola de prioridad esta definido (no supimos como hacerlo asi que lo consideramos como un puntero) si lo esta borra lo que esta apuntando, despues encolo el elemento a la cola de prioridad del pokemon, me guardo el iterador que me devuelve encolar, y asi para todos los jugadores de la coordena, despues de salir de este while que toma la cantidad de los jugadores de la coordenada, O($\#$jugadores en la coordenada), y por cada uno lo encolo a la cola eso me toma O(log n)(n la cantidad de elementos de la cola), entonces la complejidad final es O($\#$jugadores en la coordenada * log n). Esto lo hago para todas las coordenadas entonces me queda O($\#$JugadoresEsperandoCapturar * log($\#$JugadoresEsperandoCapturar)), luego antes de avanzar de coordenada, pregunto si el la que estoy parado su cola de prioridad esta vacía, si lo está pongo a false un booleano, este es el caso de que hubo alguna vez un pokemon en esa coordenada. Y despues de salir del while general termine todo entonces la complejidad final es O(($\#$(jugadoresEnRadioDeCaptura)*log($\#$(jugadoresEnRadioDeCaptura))) + |P|) 
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iCeldasValidas}(\In {g}{Game}, \In {c}{coordenada}) $\to$ res: lista(coordenada)}
	\begin{algorithmic}[1]
		\begin{scriptsize}
		\State lista(coordenada) ls $\gets$ Vacia() \Comment O(1)
		\State nat i $\gets$ 4 \Comment O(1)
		\While {i $>$ 0} \Comment O(1)
			\State AgregarAtras(ls, $<$latitud(c)+i, longitud(c)$>$) \Comment O(1)
			\If{latitud(c)-i$>$0}
				\State AgregarAtras(ls, $<$latitud(c)-i, longitud(c)$>$) \Comment O(1)
			\EndIf			
			\State AgregarAtras(ls, $<$latitud(c), longitud(c)+i$>$) \Comment O(1)
			\If{longitud(c)-i $>$0}
				\State AgregarAtras(ls, $<$latitud(c), longitud(c)-i$>$) \Comment O(1)
			\EndIf			
			\State i $\gets$ i - 1 \Comment O(1)
		\EndWhile
		\State i $\gets$ 3
		\While {i $>$ 0} \Comment O(1)
			\If{longitud(c)-(i-1)$>$0}
				\State AgregarAtras(ls, $<$latitud(c)+3, longitud(c)-(i-1)$>$) \Comment O(1)
			\EndIf
			\If{latitud(c)-(i-1)$>$0}			
				\State AgregarAtras(ls, $<$latitud(c)-(i-1), longitud(c)+3$>$) \Comment O(1)
			\EndIf
			\If{latitud(c)-3$>$0 $\wedge$ longitud(c)-(i-1)}			
				\State AgregarAtras(ls, $<$latitud(c)-3, longitud(c)-(i-1)$>$) \Comment O(1)
			\EndIf
			\If{latitud(c)-(i-1) $>$ 0 $\wedge$ longitud(c)-3 $>$ 0}
				\State AgregarAtras(ls, $<$latitud(c)-(i-1), longitud(c)-3$>$) \Comment O(1)
			\EndIf
			\If{latitud(c)-3 $>$ 0}		
				\State AgregarAtras(ls, $<$latitud(c)-3, longitud(c)+(i-1)$>$) \Comment O(1)
			\EndIf
			\If{longitud(c)-3 $>$ 0}			
				\State AgregarAtras(ls, $<$latitud(c)+(i-1), longitud(c)-3$>$) \Comment O(1)
			\EndIf			
			\State AgregarAtras(ls, $<$latitud(c)+3, longitud(c)+(i-1)$>$) \Comment O(1)
			\State AgregarAtras(ls, $<$latitud(c)+(i-1), longitud(c)+3$>$) \Comment O(1)
			\State AgregarAtras(ls, $<$latitud(c)+(i-1), longitud(c)+2$>$) \Comment O(1)
			\State AgregarAtras(ls, $<$latitud(c)+(i-1), longitud(c)+1$>$) \Comment O(1)
			\If{longitud(c)-2 $>$ 0}
				\State AgregarAtras(ls, $<$latitud(c)+(i-1), longitud(c)-2$>$) \Comment O(1)
			\EndIf
			\If{longitud(c)-1 $>$ 0}			
				\State AgregarAtras(ls, $<$latitud(c)+(i-1), longitud(c)-1$>$) \Comment O(1)
			\EndIf
			\If{latitud(c)-(i-1) $>$ 0 $\wedge$ longitud(c)-2 $>$0}
				\State AgregarAtras(ls, $<$latitud(c)-(i-1), longitud(c)-2$>$) \Comment O(1)
			\EndIf
			\If{latitud(c)-(i-1)$>$0 $\wedge$ longitud(c)-1 $>$0}			
				\State AgregarAtras(ls, $<$latitud(c)-(i-1), longitud(c)-1$>$) \Comment O(1)
			\EndIf
			\If{latitud(c)-(i-1) $>$ 0}
				\State AgregarAtras(ls, $<$latitud(c)-(i-1), longitud(c)+2$>$) \Comment O(1)
			\EndIf			
			\If{latitud(c)-(i-1) $>$0}			
				\State AgregarAtras(ls, $<$latitud(c)-(i-1), longitud(c)+1$>$) \Comment O(1)
			\EndIf			
			\State i $\gets$ i -1 \Comment O(1) 
		\EndWhile
		\State itLista(coordenada) it $\gets$ CrearIt(ls) \Comment O(1)		
		\While {HaySiguiente(it)} \Comment O(1)
			\If{PosExistente (Siguiente(it), g.mapa)} \Comment O(1)
				\State Avanzar(it) \Comment O(1) 
			\Else
				\State EleminarSiguiente(it) \Comment O(1)			
			\EndIf
		\EndWhile
		\State res $\gets$ ls \Comment O(1)
		\If{} \EndIf
		\medskip
		\Statex \underline{Complejidad:} O(1))
		\Statex \underline{Justificacion:}Como me estoy fijando un numero finito de coordenadas, y la cantidad que veo no varia porque no depende de la entrada, puedo decir que toma O(1) ver todas las celdas, luego recorro la lista para ver cuales son válidas y cuales no, que como son una cantidad constatnte de celdas recorrer la lista tambien es constante
		\end{scriptsize}
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iMoverse}(\In {j}{jugador}, \In {c}{coordenada}, \Inout {g}{Game})}
	\begin{algorithmic}[1]
		\State VerCapturas(j, c, g) \Comment O($\#$(elementosEnConj) * |PenJ|)
		\State ActualizarJugador(j, c, g) \Comment O(log $\#$(elementosEnColaDeC) +  $\#$(pokemonsDiccDeJugador)*|P|)
		\medskip
		\Statex \underline{Complejidad:}O($\#$(elementosEnConj) * |PenJ| + log $\#$(elementosEnColaDeC) + $\#$(pokemonsDiccDeJugador)*|P|) = O(($\#$(pokemonsDiccDeJugador + $\#$(elementosEnConj)) * |P|) + log $\#$(elementosEnColaDeC)) = O((PC + PS) * |P| + log(EC))
		\Statex \underline{Justificacion:}Primero veo que $\#$(elementosEnConj) son los pokemons salvajes que quedan en el juego porque esa complejidad viene de recorrer el conjunto de coordenadas de pokemons en el mapa, entonces $\#$(elementosEnConj) = PS, luego $\#$(pokemonsDiccDeJugador) es la complejidad de recorrer todas las claves del diccionario donde guardo la informacion de los pokemons de cada jugador, entonces esta complejidad esta dada por PC que es la máxima cantidad de pokemons atrapados por un jugador. Luego tengo log $\#$(elementosEnColaDeC) que viene de la parte de mover el jugador y actualizar los heap, en este caso esta complejidad se engloba por log(EC) siendo EC la máxima cantidad de jugadores esperando capturar un pokemon y por último quedan |PenJ| y |P| estas complejidad se engloban por |P$'$| siendo P$'$ la máxima longitud de un nombre de un pokemon en el juego. Luego la complejidad final queda O((PC + PS)*|P$'$| + log(EC)), aprovechando que |PenJ| y |P| estan contenidas en |P$'$|   
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iActualizarJugadorYCoordenadas}(\In {j}{jugador}, \In {c}{coordenada}, \Inout {g}{Game})}
	\begin{algorithmic}[1]
	\begin{scriptsize}
		\If{distEuclidia(c, g.jugadores[j].pos) $>$ 100 $\vee$ $\neg$(hayCamino(c, g.jugadores[j].pos, g.mapa))} \Comment O(1)
			\State g.jugadores[j].sanciones $\gets$ g.jugadores[j].sanciones +1 \Comment O(1)
			\If(g.jugadores[j].sanciones $\geq$ 4) \Comment O(1)
				\State g.jugadores[j].expulsado $\gets$ true \Comment O(1)			
			\EndIf
		\EndIf
		\If {g.jugadores[j].expulsado $=$ true} \Comment O($\#$(pokemonsDicc)*|P|)
			\State g.cantidadTotPokemons $\gets$ g.cantidadTotPokemons - g.jugadores[j].cantTotalPoke \Comment O(1)
			\State itLista(string) itPokemons $\gets$ CrearIt(Claves(Siguiente(g.jugadores[j].pokemons))) \Comment O(1)
			\While{HayMas?(itPokemons)} \Comment O($\#$(pokemonsDicc)*|P|)
				\State Significado(g.pokemons, Siguiente(itPokemons).cantTotal - Significado(g.jugadores[j].pokemons, Siguiente(itPokemons)) \Comment O(|P|+|P|) $=$ O(|P|)
				\State EliminarSiguiente(itPokemons) \Comment O(1)		
			\EndWhile
			\State EliminarSiguiente(g.jugadores[j].pokemons) \Comment O(1)
			\State g.jugadores[j].pokemons $\gets$ NULL \Comment O(1)
			\State g.jugadores[j].cantTotalPoke $\gets$ 0 \Comment O(1)
		\Else
			\If{hayPokemonCercano(g.jugadores[j].pos, g)} \Comment O(1)
				\If{hayPokemonCercano(c, g)} \Comment O(1)
					\If {posPokemonCercano(g.jugadores[j].pos, g) $\neq$ posPokemonCercano(c, g)} \Comment O(1)
						\State g.mapaInfo[g.jugadores[j].pos].MovimientosRestantes $\gets$ 0 \Comment O(1)				
					\EndIf
				\Else
					\State g.mapaInfo[g.jugadores[j].pos].MovimientosRestantes $\gets$ 0 \Comment O(1)						
				\EndIf
			\Else
				\If{hayPokemonCercano(c, g)} \Comment O(1)
					\State g.mapaInfo[c].MovimientosRestantes $\gets$ 0 \Comment O(1)
				\EndIf						
			\EndIf
		\EndIf
		\State g.jugadores[j].pos $\gets$ c \Comment O(1)
		\If{HayPokemonCerca(c, g)} \Comment O(log $\#$(elementosEnColaDeC))
			\State itDicc(jugador, itColaPrioridad(cantPokemon)) itPosicion $\gets$ DefinirRapido(g.mapaInfo[c].jugadores, j, Encolar(g.mapaInfo[posPokemonCerca(c, g)].jugEspe, g.jugadores[j].cantTotalPoke, j)) \Comment O(log $\#$(elementosEnColaDeC))
			\State g.jugadores[j].posicionMapa $\gets$ itPosicion \Comment O(1)			
			\State g.jugadores[j].posicionMapa $\gets$ itPosicion \Comment O(1)		
		\Else
			\State itDicc(jugador, itColaPrioridad(cantPokemon)) itPosicion $\gets$ DefinirRapido(g.mapaInfo[c].jugadores, j, NULL) \Comment O(1)
			\State g.jugadores[j].posicionMapa $\gets$ itPosicion \Comment O(1)			
		\EndIf
		\medskip
		\Statex \underline{Complejidad:} O(log $\#$(elementosEnColaDeC) + $\#$(pokemonsDicc)*|P|), donde P es la máxima longitud de las claves de diccionario
		\Statex \underline{Justificacion:}Primero chequeo si el jugador cometió una infracción, si lo hizo le sumo una sanción. Entonces veo si lo tengo que expulsar, si lo hago resto su cantidad de pokemons al total de pokemons en el juego porque desaparecen, despues por cada pokemon del diccionario del jugador, resto su cantidad a su respectivo pokemon en el diccString (resto a su cantidadTotal en el diccString), esto me toma O($\#$(elementos del dicc) * |P|). Si no lo tengo que expulsar simplemente defino su nueva coordenada y veo si tengo que agregarlo a una nueva cola de prioridad o no, si tengo que hacerlo tengo que revalanciar la cola eso me cuesta O(log $\#$(elementos de la cola en la coordenada c)), sino es constante. Entonces la complejidad final es O(log $\#$(elementosEnColaDeC) + $\#$(pokemonsDicc)*|P|). Para chequear que la complejidad cumple la pedida (La función la uso en moverse) veo que $\#$(elementos del diccionario de pokemons del jugador) es a lo sumo PC (máxima cantidad de pokemons atrapados por un jugador), cuando lo multiplico por |P|, veo que la complejidad está contenida en O((PS + PC) * |P|). Para la otra parte de la complejidad veo que log $\#$(elementos de la cola de C) se acota por log (EC) (donde EC es la máxima cantidad de jugadores esperando capturar un pokemon) esto pasa porque la cola está contemplada en la complejidad, pasaría, en peor caso, O(log(EC)), entonces la complejidad de esta función está contenida en la pedida.
		\end{scriptsize}
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iVerCapturas}(\In {j}{jugadores}, \In {c}{coordenadas}, \Inout {g}{Game})}
	\begin{algorithmic}[1]
		\State coordenada coordeJ $\gets$ g.jugadores[j].pos \Comment O(1)
		\State itConj(coordenadas) itPokeCoordenadas $\gets$ g.coordenadasPokemons \Comment O(1)
		\While{HaySiguiente(itPokeCoordenadas)} \Comment O($\#$(elementosEnConj) * |PenJ|)
			\If{Siguiente(itPokeCoordenadas) $neq$ coordeJ} \Comment O(1)
				\State g.mapaInfo[Siguiente(itPokeCoordenadas)].MovimientosRestantes $\gets$ g.mapaInfo[Siguiente(itPokeCoordenadas)].MovimientosRestantes +1 \Comment O(1)
				\If{g.mapaInfo[Siguiente(itPokeCoordenadas)].MovimientosRestantes $\geq$ 10} \Comment O(1) 
					\State g.mapaInfo[Siguiente(itPokeCoordenadas)].hayPokemon $\gets$ false \Comment O(1)						
					\State g.mapaInfo[Siguiente(itPokeCoordenadas)].yaSeCapturo $\gets$ true \Comment O(1)	
					\State g.mapaInfo[Siguiente(itPokeCoordenadas)].MovimientosRestantes $\gets$ 0 \Comment O(1)									
					\State Significado(g.pokemons, g.mapaInfo[Siguiente(itPokeCoordenadas)].pokemon).cantSalvaje $\gets$ Significado(g.pokemons, g.mapaInfo[Siguiente(itPokeCoordenadas)].pokemon).cantSalvaje -1 \Comment O(|P|)		
					\State jugador jug $\gets$ Proximo(g.mapaInfo[Siguiente(itPokeCoordenada)].jugEspe) \Comment O(1)
					\If{Definido?(Siguiente(g.jugadores[jug].pokemons), g.mapaInfo[Siguiente(itPokeCoordenadas)].pokemon)} \Comment O(3*|PenJ|) = O(|PenJ|)												\State Significado(Siguiente(g.jugadores[jug].pokemons), g.mapaInfo[Siguiente(itPokeCoordenadas)].pokemon) $\gets$ Significado(Siguiente(g.jugadores[jug].pokemons), g.mapaInfo[Siguiente(itPokeCoordenadas)].pokemon)	+1 \Comment O(|PenJ|)											\Else
						\State Definir(Siguiente(g.jugadores[jug].pokemons), g.mapaInfo[Siguiente(itPokeCoordenadas)].pokemon, 1) \Comment O(|PenJ|)
					\EndIf 			
				\EndIf
				\State EleminarSiguiente(itPokeCoordenada) \Comment O(1) 				
			\Else
				\State Avanzar(itPokeCoordenada) \Comment O(1)				
			\EndIf
		\EndWhile
		\medskip
		\Statex \underline{Complejidad:}O($\#$(elementosEnConj) * |PenJ|)
		\Statex \underline{Justificacion:}Recorro todas las coordenadas en donde hay pokemons y por cada una veo si se produce una captura (movimientosRestantes >= 10), si se podruce busco el jugador que lo captura (Pido tope a la colaDePrioridad) en O(log $\#$(elementosCola))) y Defino al pokemon en el diccionario de pokemons del jugador (O(|PenJ|)) y si ya estaba definido le modifico el significado en ambos casos me toma lo mismo en complejidad temporal, despues pongo el booleano yaSeAtrapo en true. Entonces la complejidad final es O($\#$(elementosEnConj) * |PenJ|). Para verla con el enunciado queda O(PS * |P|) 
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iConectarse}(\In {j}{jugador}, \In {c}{coordenada}, \Inout {g}{Game})}
	\begin{algorithmic}[1]
		\State g.jugadores[j].conectado $\gets$ true \Comment O(1)
		\State g.jugadores[j].pos $\gets$ c \Comment O(1)
		\If{HayPokemonCerca(c, g)} \Comment O(log $\#$(elementosEnColaDeC))
			\State itDicc(jugador, itColaPrioridad(cantPokemon)) itPosicion $\gets$ DefinirRapido(g.mapaInfo[c].jugadores, j, Encolar(g.mapaInfo[posPokemonCerca(c, g)].jugEspe, g.jugadores[j].cantTotalPoke, j)) \Comment O(log $\#$(elementosEnColaDeC))
			\State g.jugadores[j].posicionMapa $\gets$ itPosicion \Comment O(1)			
			\State g.jugadores[j].posicionMapa $\gets$ itPosicion \Comment O(1)		
		\Else
			\State itDicc(jugador, itColaPrioridad(cantPokemon)) itPosicion $\gets$ DefinirRapido(g.mapaInfo[c].jugadores, j, NULL) \Comment O(1)
			\State g.jugadores[j].posicionMapa $\gets$ itPosicion \Comment O(1)			
		\EndIf		
		\medskip
		\Statex \underline{Complejidad:} O(log $\#$(elementosEnColaDeC))
		\Statex \underline{Justificacion:}A la hora de conectarse, primero veo si en la coordenada c hay un pokemon cerca, si lo hay agrego el jugador a la cola de prioridad de la coordenada del pokemon eso me cuesta O(log $\#$(elementosEnCola)), si no hay pokemon cerca simplemente no existe el iterado. Luego cargo los datos necesarios para el jugador  
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iDesconectarse}(\In {j}{jugador}, \Inout {g}{Game})}
	\begin{algorithmic}[1]
		\State g.jugadores[j].conectado $\gets$ false \Comment O(1)
		\If{SiguienteSignificado(g.jugadores[j].posicionMapa) $\neq$ NULL} \Comment O(log $\#$(elementosEnCola))
			\State Borrar(SiguienteSignificado(g.jugadores[j].posicionMapa)) \Comment O(log $\#$(elementosEnCola))
			\State EleminarSiguiente(g.jugadores[j].posicionMapa) \Comment O(1)
			\State g.jugadores[j].posicionMapa $\gets$ NULL \Comment O(1)		
		\Else
			\State EleminarSiguiente(g.jugadores[j].posicionMapa) \Comment O(1)
			\State g.jugadores[j].posicionMapa $\gets$ NULL \Comment O(1)
		\EndIf		
		\medskip
		\Statex \underline{Complejidad:} O(log $\#$(elementosEnCola))
		\Statex \underline{Justificacion:}Cuando un jugador se desconecta, primero actualizo su flag de conectado a false y despues veo si esta en alguna cola de prioridad, si lo está elimino el nodo al que apunta (reordeno la cola) y despues borro el diccionario en donde está definido y pongo a null el iterador. Si está en una cola la complejidad (para reordenoar) toma O(log $\#$(elementosEnCola)) sino toma O(1)  
	\end{algorithmic}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OBSERVADORES BASICOS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{algorithm}[H]{\textbf{iMapa}(\In {g}{Game}) $\to$ res: mapa}
	\begin{algorithmic}[1]
		\State res $\gets$ g.mapa \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:} Devuelve la instancia de mapa que tenemos guardada
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iJugadores}(\In {g}{Game}) $\to$ res: conj(jugador)}
	\begin{algorithmic}[1]
		\State res $\gets$ CrearIt(g) \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:} Crea un iterador a jugadores que tiene orden de 1 y lo devuelve
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iEstaConectado}(\In {j}{jugador}, \In {g}{Game}) $\to$ res: conj(jugador)}
	\begin{algorithmic}[1]
		\State res $\gets$ g.jugadores[j].conectado \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:} Es una asignaci\'on, un acceso de O(1) a un vector por el id del jugador y ah\'i guardamos una tupla con informaci\'on del jugador, en particular si est\'a \'o no conectado
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iSanciones}(\In {j}{jugador}, \In {g}{Game}) $\to$ res: nat}
	\begin{algorithmic}[1]
		\State res $\gets$ g.jugadores[j].sanciones \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:} Es una asignaci\'on, un acceso de O(1) a un vector por el id del jugador y ah\'i guardamos una tupla con informaci\'on del jugador, en particular la cantidad de sanciones que tiene
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iPosicion}(\In {j}{jugador}, \In {g}{Game}) $\to$ res: coordenada}
	\begin{algorithmic}[1]
		\State res $\gets$ g.jugadores[j].pos \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:} Es una asignaci\'on, un acceso de O(1) a un vector por el id del jugador y ah\'i guardamos una tupla con informaci\'on del jugador, en particular la posici\'on actual del jugador cuando esta conectado
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iPokemons}(\In {j}{jugador}, \In {g}{Game}) $\to$ res: itDicc($<Pokemon, cantidad>$)}
	\begin{algorithmic}[1]
		\State res $\gets$ CrearIt(Siguiente(g.jugadores[j].pokemons)) \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:} Dentro de jugadores guardamos un iterador a Dicc(<Pokemon, Cantidad>) que est\'a guardado en Game. De esta forma en el vector de jugadores guardamos estructuras simples de copiar, esto era necesario por la complejidad del agregar jugador (ver AgregarJugador). Tanto la asignaci\'on y la creaci\'on del iterador y el siguiente del iterador de lista son todos O(1)
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iExpulsados}(\In {g}{Game}) $\to$ res: conj(jugador)}
	\begin{algorithmic}[1]
		\State res $\gets$ Vac\'io() \Comment O(1)
		\State tam $\gets$ Longitud(g.jugadores) \Comment O(1)
		\State \textbf{for} n $\gets$ 0 \textbf{to} tam \Comment O(J)
		\State \,\,\,\,AgregarRapido(res, g.jugadores[n].jug) \Comment O(copy(jugador))
		\medskip
		\Statex \underline{Complejidad:} O(J)
		\Statex \underline{Justificacion:} El for se ejecuta J veces y como jugador es un nat, el costo de copiarlo es O(1) entonces la complejidad es O(J)
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iPosConPokemons}(\In {g}{Game}) $\to$ res: conj(coordenada)}
	\begin{algorithmic}[1]
		\State res $\gets$ g.coordenadasConPokemons \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:} Devolvemos el conjunto de coordenadas con Pokemones. La asignaci\'on al ser de un tipo \textbf{no} primitivo tanto res como g.coordenadasConPokemons referencian a la misma estructura f\'isica (del apunte de dise\~no)
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iPokemonEnPos}(\In {c}{coordenada}, \In {g}{Game}) $\to$ res: pokemon}
	\begin{algorithmic}[1]
		\State res $\gets$ g.mapainfo[Altitud(c)][Longitud(c)].pokemon \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:} El acceso a mapainfo que es una matriz es O(1) y tenemos solo una asignaci\'on
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iCantMovimientosParaCaptura}(\In {c}{coordenada}, \In {g}{Game}) $\to$ res: nat}
	\begin{algorithmic}[1]
		\State res $\gets$ 10 - g.mapainfo[Altitud(c)][Longitud(c)].MovimientosRestantes \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:} El acceso a mapainfo que es una matriz es O(1), tenemos solo una asignaci\'on y una resta
	\end{algorithmic}
\end{algorithm}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Otras operaciones
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{algorithm}[H]{\textbf{iJugadoresConectados}(\In {g}{Game}) $\to$ res: conj(jugador)}
	\begin{algorithmic}[1]
		\State res $\gets$ Vac\'io() \Comment O(1)
		\State tam $\gets$ Longitud(g.jugadores) \Comment O(1)
		\State \textbf{for} n $\gets$ 0 \textbf{to} tam \Comment O(J)
		\State \IF g.jugadores[n].conectado THEN AgregarRapido(res, g.jugadores[n].jug) ELSE FI \Comment O(copy($\alpha$))
		\State \textbf{endfor}
		\medskip
		\Statex \underline{Complejidad:} O(J)
		\Statex \underline{Justificacion:} El for se ejecuta J veces el agregar rapido tiene el costo de copiar el elemento J veces, pero al ser jugador un natural, el costo es O(1) luego el costo de la funci\'on es O(J)
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iPuedoAgregarPokemon}(\In {c}{Coordenada}, \In {g}{Game}) $\to$ res: Bool}
	\begin{algorithmic}[1]
		\State res $\gets$ True \Comment O(1)
		\If {PosExistente(c, g.mapa)} \Comment O(1)
			\State coordPokemons $\gets$ PosConPokemons(g) \Comment O(1)
			\State iter $\gets$ CrearIt(coordPokemons) \Comment O(1)
			\While {HaySiguiente(iter)} \Comment O(PS)
				\State \IF DistEuclidea(Siguiente(iter), c) < 25 THEN res $\gets$ False ELSE FI \Comment O(1)
				\State Avanzar(iter) \Comment O(1)
			\EndWhile
		\Else
		\EndIf
		\medskip
		\Statex \underline{Complejidad:} O(PS)
		\Statex \underline{Justificacion:} Son todas operaciones de O(1) pero el while se ejecuta PS veces ejecutando c\'odigo O(1) por lo tanto todo tiene complejidad O(PS)
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iHayPokemonCercano}(\In {c}{Coordenada}, \In {g}{Game}) $\to$ res: Bool}
	\begin{algorithmic}[1]
		\State res $\gets$ False \Comment O(1)
		\If {PosExistente(c, g.mapa)} \Comment O(1)
			\State coordCercanas $\gets$ CeldasValidas(g, c) \Comment O(1)
			\State iter $\gets$ CrearIt(coordPokemons) \Comment O(1)
			\While {HaySiguiente(iter)} \Comment O(1)
				\State coor $\gets$ Siguiente(iter) \Comment O(1)
				\State \IF g.mapainfo[Altitud(coor)][Longitud(coor)].hayPokemon THEN res $\gets$ True ELSE FI \Comment O(1)
				\State Avanzar(iter) \Comment O(1)
			\EndWhile
		\EndIf
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:} Son todas asignaciones y operaciones en O(1). El \'unico detalle es la cantidad de coordenadas que devuelve CeldasValidas. Como la funci\'on devuelve todas las coordenadas a radio 4 de la coordenada que nos pasan, sabemos que devuelve una cantidad constante de coordenadas (salvo en el borde del mapa que devuelve menos pero que igual est\'a acotada por el radio 4) y al ser constante se puede despreciar y es O(1)
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iIndiceRareza}(\In {p}{pokemon}, \In {g}{Game}) $\to$ res: nat}
	\begin{algorithmic}[1]
		
		\State res $\gets$ 100 \Comment O(1)
		\State nat aux $\gets$ significado(j.gokemons, p).cantTotal \Comment O(|s|)
		\State aux $\gets$ aux $/$ g.cantTotPokemons	\Comment O(1)
		\State res $\gets$ res - aux $*$ 100		\Comment O(1)
		
		\medskip
		\Statex \underline{Complejidad:} O(|s|)
		\Statex \underline{Justificacion:} Devuelve el índice de rareza del pokemon pedido. La única operación que tiene complejidad mayor que O(1) es buscar en el trie de pokemons, la complejidad de esta operación es en peor caso buscar el nombre de pokemon más largo, por lo tanto la complejidad es O(|s|).
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iCantPokemonsTotales}(\In {g}{Game}) $\to$ res: nat}
	\begin{algorithmic}[1]
		
		\State res $\gets$ g.cantTotPokemons \Comment O(1)
		
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:} Devuelve el valor de un elemento almacenado en la estructura, es una referencia y una asignación, operaciones de complejidad de orden constante.
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iPosPokemonCercano}(\In {c}{Coordenada}, \In {g}{Game}) $\to$ res: Coordenada}
	\begin{algorithmic}[1]
		
		\If {PosExistente(c, g.mapa)} \Comment O(1)
			\State coordCercanas $\gets$ CeldasValidas(g, c) \Comment O(1)
			\State iter $\gets$ CrearIt(coordPokemons) \Comment O(1)
			\While {HaySiguiente(iter)} \Comment O(1)
				\State coor $\gets$ Siguiente(iter) \Comment O(1)
				\If {g.mapainfo[Altitud(coor)][Longitud(coor)].hayPokemon}
					\State res $\gets$ coor FI \Comment O(1)
				\EndIf				
				\State Avanzar(iter) \Comment O(1)
			\EndWhile
		\EndIf
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:} Son todas asignaciones y operaciones en O(1). El \'unico detalle es la cantidad de coordenadas que devuelve CeldasValidas. Como la funci\'on devuelve todas las coordenadas a radio 4 de la coordenada que nos pasan, sabemos que devuelve una cantidad constante de coordenadas (salvo en el borde del mapa que devuelve menos pero que igual est\'a acotada por el radio 4) y al ser constante se puede despreciar y es O(1)
	\end{algorithmic}
\end{algorithm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Iterador
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\ttitulo {Algoritmos del iterador}

\begin{algorithm}[H]{\textbf{iCrearIt}(\In {g}{game}) $\to$ res: iter))}
	\begin{algorithmic}[1]
		\State res $\gets$ <0, puntero(g.jugadores)> \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:}Crea un iterador al princio del vector, solo 
		realiza una asignación  
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iHayMas?}(\In {it}{iter}) $\to$ res: bool))}
	\begin{algorithmic}[1]
		\State bool b $\gets$ false
		\State nat i $\gets$ it.posicion \Comment O(1)
		\While {i $<$ it.vector$\to$ longitud $\wedge$ $\neg$b} \Comment O(longitud(v))
			\If {it.vector$\to$ elementos[i].expulsado $=$ false} \Comment O(1)
				\State b $\gets$ true \Comment O(1)
			\EndIf
		\State i $\gets$ i +1 \Comment O(1)		
		\EndWhile
		\State res $\gets$ b
		\medskip
		\Statex \underline{Complejidad:} O(longitud(v))
		\Statex \underline{Justificacion:}En el peor de lo casos hay que recorrer todo el vector para saber si existe otro elemento

\end{algorithmic}
\end{algorithm}	
		
\begin{algorithm}[H]{\textbf{iAvanzar}(\Inout {it}{iter})}
	\begin{algorithmic}[1]
		\State bool b $\gets$ false
		\State nat i $\gets$ it.posicion \Comment O(1)
		\While {i $<$ it.vector$\to$ longitud $\wedge$ $\neg$b} \Comment O(longitud(v))
			\If {it.vector$\to$ elementos[i].expulsado $=$ false} \Comment O(1)
				\State b $\gets$ true \Comment O(1)
			\EndIf
		\State i $\gets$ i +1 \Comment O(1)		
		\EndWhile
		\State it.posicion $\gets$ (i-1) \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(longitud(v))
		\Statex \underline{Justificacion:}Recorre el vector y para en el primer elemento válido, que existe por la precondición de la función, luego actualiza la posición del iterador  
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iActual}(\In {it}{iter}) $\to$ res: nat}
	\begin{algorithmic}[1]
		\State res $\gets$ it.posicion \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(1)
		\Statex \underline{Justificacion:}Devuelve la id del jugador que apunta el iterador  
	\end{algorithmic}
\end{algorithm}
	
\begin{algorithm}[H]{\textbf{iSiguientes}(\In {it}{iter}) $\to$ res: lista(jugadores)))}
	\begin{algorithmic}[1]
		\State lista(nat) ls $\gets$ Vacia() \Comment O(1), crea una lista vacia
		\State nat i $\gets$ it.posicion \Comment O(1)
		\While {i $<$ it.vector$\to$ longitud} \Comment O(longitud(v))
			\If {it.vector$\to$ elementos[i].expulsado $=$ false} \Comment O(1)
				\State AgregarAtras(ls, it.posicion) \Comment O(1)
			\EndIf
		\State i $\gets$ i +1 \Comment O(1)		
		\EndWhile
		\State res $\gets$ ls \Comment O(1)
		\medskip
		\Statex \underline{Complejidad:} O(longitud(v))
		\Statex \underline{Justificacion:}Para devolver una lista con los elementos que quedan por recorrer, recorro todo el vector viendo que elementos son válidos y si un elemento es válido lo agrego a una lista.
	\end{algorithmic}
\end{algorithm}

\end{Algoritmos}
